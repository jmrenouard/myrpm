#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Expect.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPECT';
  # -*-cperl-*-
  # Please see the .pod files for documentation. This module is copyrighted
  # as per the usual perl legalese:
  # Copyright (c) 1997 Austin Schutz.
  # expect() interface & functionality enhancements (c) 1999 Roland Giersig.
  #
  # All rights reserved. This program is free software; you can
  # redistribute it and/or modify it under the same terms as Perl
  # itself.
  #
  # Don't blame/flame me if you bust your stuff.
  # Austin Schutz <ASchutz@users.sourceforge.net>
  #
  # This module now is maintained by
  # Roland Giersig <RGiersig@cpan.org>
  #
  
  use 5.006;				# 4 won't cut it.
  
  package Expect;
  
  use IO::Pty 1.03;		# We need make_slave_controlling_terminal()
  use IO::Tty;
  
  use strict 'refs';
  use strict 'vars';
  use strict 'subs';
  use POSIX qw(:sys_wait_h :unistd_h); # For WNOHANG and isatty
  use Fcntl qw(:DEFAULT); # For checking file handle settings.
  use Carp qw(cluck croak carp confess);
  use IO::Handle ();
  use Exporter ();
  use Errno;
  
  # This is necessary to make routines within Expect work.
  
  @Expect::ISA = qw(IO::Pty Exporter);
  @Expect::EXPORT = qw(expect exp_continue exp_continue_timeout);
  
  BEGIN {
    $Expect::VERSION = '1.21';
    # These are defaults which may be changed per object, or set as
    # the user wishes.
    # This will be unset, since the default behavior differs between 
    # spawned processes and initialized filehandles.
    #  $Expect::Log_Stdout = 1;
    $Expect::Log_Group = 1;
    $Expect::Debug = 0;
    $Expect::Exp_Max_Accum = 0; # unlimited
    $Expect::Exp_Internal = 0;
    $Expect::IgnoreEintr = 0;
    $Expect::Manual_Stty = 0;
    $Expect::Multiline_Matching = 1;
    $Expect::Do_Soft_Close = 0;
    @Expect::Before_List = ();
    @Expect::After_List = ();
    %Expect::Spawned_PIDs = ();
  }
  
  sub version {
    my($version) = shift;
    warn "Version $version is later than $Expect::VERSION. It may not be supported" if (defined ($version) && ($version > $Expect::VERSION));
  
    die "Versions before 1.03 are not supported in this release" if ((defined ($version)) && ($version < 1.03));
    return $Expect::VERSION;
  }
  
  sub new {
  
    my ($class) = shift;
    $class = ref($class) if ref($class); # so we can be called as $exp->new()
  
    # Create the pty which we will use to pass process info.
    my($self) = new IO::Pty;
    die "$class: Could not assign a pty" unless $self;
    bless $self => $class;
    $self->autoflush(1);
  
    # This is defined here since the default is different for
    # initialized handles as opposed to spawned processes.
    ${*$self}{exp_Log_Stdout} = 1;
    $self->_init_vars();
  
    if (@_) {
      # we got add'l parms, so pass them to spawn
      return $self->spawn(@_);
    }
    return $self;
  }
  
  sub spawn {
    my ($class) = shift;
    my $self;
  
    if (ref($class)) {
      $self = $class;
    } else {
      $self = $class->new();
    }
  
    croak "Cannot reuse an object with an already spawned command"
      if exists ${*$self}{"exp_Command"};
    my(@cmd) = @_;	# spawn is passed command line args.
    ${*$self}{"exp_Command"} = \@cmd;
  
    # set up pipe to detect childs exec error
    pipe(FROM_CHILD, TO_PARENT) or die "Cannot open pipe: $!";
    pipe(FROM_PARENT, TO_CHILD) or die "Cannot open pipe: $!";
    TO_PARENT->autoflush(1);
    TO_CHILD->autoflush(1);
    eval {
      fcntl(TO_PARENT, Fcntl::F_SETFD, Fcntl::FD_CLOEXEC);
    };
  
    my $pid = fork;
  
    unless (defined ($pid)) {
      warn "Cannot fork: $!" if $^W;
      return undef;
    }
  
    if($pid) {
      # parent
      my $errno;
      ${*$self}{exp_Pid} = $pid;
      close TO_PARENT;
      close FROM_PARENT;
      $self->close_slave();
      $self->set_raw() if $self->raw_pty and isatty($self);
      close TO_CHILD; # so child gets EOF and can go ahead
  
      # now wait for child exec (eof due to close-on-exit) or exec error
      my $errstatus = sysread(FROM_CHILD, $errno, 256);
      die "Cannot sync with child: $!" if not defined $errstatus;
      close FROM_CHILD;
      if ($errstatus) {
        $! = $errno+0;
        warn "Cannot exec(@cmd): $!\n" if $^W;
        return undef;
      }
    }
    else {
      # child
      close FROM_CHILD;
      close TO_CHILD;
  
      $self->make_slave_controlling_terminal();
      my $slv = $self->slave()
        or die "Cannot get slave: $!";
  
      $slv->set_raw() if $self->raw_pty;
      close($self);
  
      # wait for parent before we detach
      my $buffer;
      my $errstatus = sysread(FROM_PARENT, $buffer, 256);
      die "Cannot sync with parent: $!" if not defined $errstatus;
      close FROM_PARENT;
  
      close(STDIN);
      open(STDIN,"<&". $slv->fileno())
        or die "Couldn't reopen STDIN for reading, $!\n";
      close(STDOUT);
      open(STDOUT,">&". $slv->fileno())
        or die "Couldn't reopen STDOUT for writing, $!\n";
      close(STDERR);
      open(STDERR,">&". $slv->fileno())
        or die "Couldn't reopen STDERR for writing, $!\n";
  
      { exec(@cmd) };
      print TO_PARENT $!+0;
      die "Cannot exec(@cmd): $!\n";
    }
  
    # This is sort of for code compatibility, and to make debugging a little
    # easier. By code compatibility I mean that previously the process's
    # handle was referenced by $process{Pty_Handle} instead of just $process.
    # This is almost like 'naming' the handle to the process.
    # I think this also reflects Tcl Expect-like behavior.
    ${*$self}{exp_Pty_Handle} = "spawn id(".$self->fileno().")";
    if ((${*$self}{"exp_Debug"}) or (${*$self}{"exp_Exp_Internal"})) {
      cluck("Spawned '@cmd'\r\n",
  	  "\t${*$self}{exp_Pty_Handle}\r\n",
  	  "\tPid: ${*$self}{exp_Pid}\r\n",
  	  "\tTty: ".$self->SUPER::ttyname()."\r\n",
  	 );
    }
    $Expect::Spawned_PIDs{${*$self}{exp_Pid}} = undef;
    return $self;
  }
  
  
  sub exp_init {
    # take a filehandle, for use later with expect() or interconnect() .
    # All the functions are written for reading from a tty, so if the naming
    # scheme looks odd, that's why.
    my ($class) = shift;
    my($self) = shift;
    bless $self, $class;
    croak "exp_init not passed a file object, stopped"
      unless defined($self->fileno());
    $self->autoflush(1);
    # Define standard variables.. debug states, etc.
    $self->_init_vars();
    # Turn of logging. By default we don't want crap from a file to get spewed
    # on screen as we read it.
    ${*$self}{exp_Log_Stdout} = 0;
    ${*$self}{exp_Pty_Handle} = "handle id(".$self->fileno().")";
    ${*$self}{exp_Pty_Handle} = "STDIN" if $self->fileno() == fileno (STDIN);
    print STDERR "Initialized ${*$self}{exp_Pty_Handle}.'\r\n" 
      if ${*$self}{"exp_Debug"};
    return $self;
  }
  
  # make an alias
  *init = \&exp_init;
  
  ######################################################################
  # We're happy OOP people. No direct access to stuff.
  # For standard read-writeable parameters, we define some autoload magic...
  my %Writeable_Vars = ( debug            => 'exp_Debug',
  		       exp_internal     => 'exp_Exp_Internal',
  		       do_soft_close    => 'exp_Do_Soft_Close',
  		       max_accum        => 'exp_Max_Accum',
  		       match_max        => 'exp_Max_Accum',
  		       notransfer       => 'exp_NoTransfer',
  		       log_stdout       => 'exp_Log_Stdout',
  		       log_user         => 'exp_Log_Stdout',
  		       log_group        => 'exp_Log_Group',
  		       manual_stty      => 'exp_Manual_Stty',
  		       restart_timeout_upon_receive => 'exp_Continue',
  		       raw_pty           => 'exp_Raw_Pty',
  		     );
  my %Readable_Vars = ( pid               => 'exp_Pid',
  		      exp_pid           => 'exp_Pid',
  		      exp_match_number  => 'exp_Match_Number',
  		      match_number      => 'exp_Match_Number',
  		      exp_error         => 'exp_Error',
  		      error             => 'exp_Error',
  		      exp_command       => 'exp_Command',
  		      command           => 'exp_Command',
  		      exp_match         => 'exp_Match',
  		      match             => 'exp_Match',
  		      exp_matchlist     => 'exp_Matchlist',
  		      matchlist         => 'exp_Matchlist',
  		      exp_before        => 'exp_Before',
  		      before            => 'exp_Before',
  		      exp_after         => 'exp_After',
  		      after             => 'exp_After',
  		      exp_exitstatus    => 'exp_Exit',
  		      exitstatus        => 'exp_Exit',
  		      exp_pty_handle    => 'exp_Pty_Handle',
  		      pty_handle        => 'exp_Pty_Handle',
  		      exp_logfile       => 'exp_Log_File',
  		      logfile           => 'exp_Log_File',
  		      %Writeable_Vars,
  		    );
  
  sub AUTOLOAD {
    my $self = shift;
    my $type = ref($self)
      or croak "$self is not an object";
  
    use vars qw($AUTOLOAD);
    my $name = $AUTOLOAD;
    $name =~ s/.*:://;		# strip fully-qualified portion
  
    unless (exists $Readable_Vars{$name}) {
      croak "ERROR: cannot find method `$name' in class $type";
    }
    my $varname = $Readable_Vars{$name};
    my $tmp;
    $tmp = ${*$self}{$varname} if exists ${*$self}{$varname};
  
    if (@_) {
      if (exists $Writeable_Vars{$name}) {
        my $ref = ref($tmp);
        if ($ref eq 'ARRAY') {
  	${*$self}{$varname} = [ @_ ];
        } elsif ($ref eq 'HASH') {
  	${*$self}{$varname} = { @_ };
        } else {
  	${*$self}{$varname} = shift;
        }
      } else {
        carp "Trying to set read-only variable `$name'"
  	if $^W;
      }
    }
  
    my $ref = ref($tmp);
    return (wantarray? @{$tmp} : $tmp) if ($ref eq 'ARRAY');
    return (wantarray? %{$tmp} : $tmp) if ($ref eq 'HASH');
    return $tmp;
  }
  
  ######################################################################
  
  sub set_seq {
    # Set an escape sequence/function combo for a read handle for interconnect.
    # Ex: $read_handle->set_seq('',\&function,\@parameters); 
    my($self) = shift;
    my($escape_sequence,$function) = (shift,shift);
    ${${*$self}{exp_Function}}{$escape_sequence} = $function;
    if ((!defined($function)) ||($function eq 'undef')) {
      ${${*$self}{exp_Function}}{$escape_sequence} = \&_undef;
    }
    ${${*$self}{exp_Parameters}}{$escape_sequence} = shift;
    # This'll be a joy to execute. :)
    if ( ${*$self}{"exp_Debug"} ) {
      print STDERR "Escape seq. '" . $escape_sequence;
      print STDERR "' function for ${*$self}{exp_Pty_Handle} set to '";
      print STDERR ${${*$self}{exp_Function}}{$escape_sequence};
      print STDERR "(" . join(',', @_) . ")'\r\n";
    }
  }
  
  sub set_group {
    my($self) = shift;
    my($write_handle);
    # Make sure we can read from the read handle
    if (! defined($_[0])) {
      if (defined (${*$self}{exp_Listen_Group})) {
        return @{${*$self}{exp_Listen_Group}};
      } else {
        # Refrain from referencing an undef
        return undef;
      }
    }
    @{${*$self}{exp_Listen_Group}} = ();
    if ($self->_get_mode() !~ 'r') {
      warn("Attempting to set a handle group on ${*$self}{exp_Pty_Handle}, ",
  	 "a non-readable handle!\r\n");
    }
    while ($write_handle = shift) {
      if ($write_handle->_get_mode() !~ 'w') {
        warn("Attempting to set a non-writeable listen handle ",
  	   "${*$write_handle}{exp_Pty_handle} for ",
  	   "${*$self}{exp_Pty_Handle}!\r\n");
      }
      push (@{${*$self}{exp_Listen_Group}},$write_handle);
    }
  }
  
  sub log_file {
      my $self = shift;
  
      return(${*$self}{exp_Log_File})
        if not @_;  # we got no param, return filehandle
  
      my $file = shift;
      my $mode = shift || "a";
  
      if (${*$self}{exp_Log_File} and ref(${*$self}{exp_Log_File}) ne 'CODE') {
        close(${*$self}{exp_Log_File});
      }
      ${*$self}{exp_Log_File} = undef;
      return if (not $file);
      my $fh = $file;
      if (not ref($file)) {
        # it's a filename
        $fh = new IO::File $file, $mode
  	or croak "Cannot open logfile $file: $!";
      }
      if (ref($file) ne 'CODE') {
        croak "Given logfile doesn't have a 'print' method"
  	if not $fh->can("print");
        $fh->autoflush(1);		# so logfile is up to date
      }
  
      ${*$self}{exp_Log_File} = $fh;
  }
  
  
  # I'm going to leave this here in case I might need to change something.
  # Previously this was calling `stty`, in a most bastardized manner.
  sub exp_stty {
    my($self) = shift;
    my($mode) = "@_";
    
    return undef unless defined($mode);
    if (not defined $INC{"IO/Stty.pm"}) {
      carp "IO::Stty not installed, cannot change mode";
      return undef;
    }
  
    if (${*$self}{"exp_Debug"}) {
      print STDERR "Setting ${*$self}{exp_Pty_Handle} to tty mode '$mode'\r\n";
    }
    unless (POSIX::isatty($self)) {
      if (${*$self}{"exp_Debug"} or $^W) {
        warn "${*$self}{exp_Pty_Handle} is not a tty. Not changing mode";
      }
      return '';			# No undef to avoid warnings elsewhere.
    }
    IO::Stty::stty($self, split(/\s/,$mode));
  }
  
  *stty = \&exp_stty;
  
  # If we want to clear the buffer. Otherwise Accum will grow during send_slow
  # etc. and contain the remainder after matches.
  sub clear_accum {
    my ($self) = shift;
    my ($temp) = (${*$self}{exp_Accum});
    ${*$self}{exp_Accum} = '';
    # return the contents of the accumulator.
    return $temp;
  }
  
  sub set_accum {
    my ($self) = shift;
    my ($temp) = (${*$self}{exp_Accum});
    ${*$self}{exp_Accum} = shift;
    # return the contents of the accumulator.
    return $temp;
  }
  
  ######################################################################
  # define constants for pattern subs
  sub exp_continue() { "exp_continue" }
  sub exp_continue_timeout() { "exp_continue_timeout" }
  
  ######################################################################
  # Expect on multiple objects at once.
  #
  # Call as Expect::expect($timeout, -i => \@exp_list, @patternlist,
  #                       -i => $exp, @pattern_list, ...);
  # or $exp->expect($timeout, @patternlist, -i => \@exp_list, @patternlist,
  #                 -i => $exp, @pattern_list, ...);
  #
  # Patterns are arrays that consist of
  #   [ $pattern_type, $pattern, $sub, @subparms ]
  #
  #   Optional $pattern_type is '-re' (RegExp, default) or '-ex' (exact);
  #
  #   $sub is optional CODE ref, which is called as &{$sub}($exp, @subparms)
  #     if pattern matched; may return exp_continue or exp_continue_timeout.
  #
  # Old-style syntax (pure pattern strings with optional type)  also supported.
  #
  
  sub expect {
    my $self;
    print STDERR ("expect(@_) called...\n") if $Expect::Debug;
    if (defined($_[0])) {
      if (ref($_[0]) and $_[0]->isa('Expect')) {
        $self = shift;
      } elsif ($_[0] eq 'Expect') {
        shift;	# or as Expect->expect
      }
    }
    croak "expect(): not enough arguments, should be expect(timeout, [patterns...])" if @_ < 1;
    my $timeout = shift;
    my $timeout_hook = undef;
  
    my @object_list;
    my %patterns;
  
    my @pattern_list;
    my @timeout_list;
    my $curr_list;
  
    if ($self) {
      $curr_list = [$self];
    } else {
      # called directly, so first parameter must be '-i' to establish
      # object list.
      $curr_list = [];
      croak "expect(): ERROR: if called directly (not as \$obj->expect(...), but as Expect::expect(...), first parameter MUST be '-i' to set an object (list) for the patterns to work on."
        if ($_[0] ne '-i');
    }
    # Let's make a list of patterns wanting to be evaled as regexps.
    my $parm;
    my $parm_nr = 1;
    while (defined($parm = shift)) {
      print STDERR ("expect(): handling param '$parm'...\n") if $Expect::Debug;
      if (ref($parm)) {
        if (ref($parm) eq 'ARRAY') {
  	my $err = _add_patterns_to_list(\@pattern_list, \@timeout_list,
  					$parm_nr, $parm);
  	carp ("expect(): Warning: multiple `timeout' patterns (",
  	      scalar(@timeout_list), ").\r\n")
  	  if @timeout_list > 1;
  	$timeout_hook = $timeout_list[-1] if $timeout_list[-1];
  	croak $err if $err;
  	$parm_nr++;
        } else {
  	croak ("expect(): Unknown pattern ref $parm");
        }
      } else {
        # not a ref, is an option or raw pattern
        if (substr($parm, 0, 1) eq '-') {
  	# it's an option
  	print STDERR ("expect(): handling option '$parm'...\n")
  	  if $Expect::Debug;
  	if ($parm eq '-i') {
  	  # first add collected patterns to object list
  	  if (scalar(@$curr_list)) {
  	    push @object_list, $curr_list if not exists $patterns{"$curr_list"};
  	    push @{$patterns{"$curr_list"}}, @pattern_list;
  	    @pattern_list = ();
  	  }
  	  # now put parm(s) into current object list
  	  if (ref($_[0]) eq 'ARRAY') {
  	    $curr_list = shift;
  	  } else {
  	    $curr_list = [ shift ];
  	  }
  	} elsif ($parm eq '-re'
  		 or $parm eq '-ex') {
  	  if (ref($_[1]) eq 'CODE') {
  	    push @pattern_list, [ $parm_nr, $parm, shift, shift ];
  	  } else {
  	    push @pattern_list, [ $parm_nr, $parm, shift, undef ];
  	  }
  	  $parm_nr++;
  	} else {
  	  croak ("Unknown option $parm");
  	}
        } else {
  	# a plain pattern, check if it is followed by a CODE ref
  	if (ref($_[0]) eq 'CODE') {
  	  if ($parm eq 'timeout') {
  	    push @timeout_list, shift;
  	    carp ("expect(): Warning: multiple `timeout' patterns (",
  		  scalar(@timeout_list), ").\r\n")
  	      if @timeout_list > 1;
  	    $timeout_hook = $timeout_list[-1] if $timeout_list[-1];
  	  } elsif ($parm eq 'eof') {
  	    push @pattern_list, [ $parm_nr, "-$parm", undef, shift ];
  	  } else {
  	    push @pattern_list, [ $parm_nr, '-ex', $parm, shift ];
  	  }
  	} else {
  	  print STDERR ("expect(): exact match '$parm'...\n")
  	    if $Expect::Debug;
  	  push @pattern_list, [ $parm_nr, '-ex', $parm, undef ];
  	}
  	$parm_nr++;
        }
      }
    }
  
    # add rest of collected patterns to object list
    carp "expect(): Empty object list" unless $curr_list;
    push @object_list, $curr_list if not exists $patterns{"$curr_list"};
    push @{$patterns{"$curr_list"}}, @pattern_list;
  
    my $debug = $self ? ${*$self}{exp_Debug} : $Expect::Debug;
    my $internal = $self ? ${*$self}{exp_Exp_Internal} : $Expect::Exp_Internal;
  
    # now start matching...
  
    if (@Expect::Before_List) {
      print STDERR ("Starting BEFORE pattern matching...\r\n")
        if ($debug or $internal);
      _multi_expect(0, undef, @Expect::Before_List);
    }
  
    cluck ("Starting EXPECT pattern matching...\r\n")
      if ($debug or $internal);
    my @ret;
    @ret = _multi_expect($timeout, $timeout_hook,
  		       map { [$_, @{$patterns{"$_"}}] } @object_list);
  
    if (@Expect::After_List) {
      print STDERR ("Starting AFTER pattern matching...\r\n")
        if ($debug or $internal);
      _multi_expect(0, undef, @Expect::After_List);
    }
  
    wantarray ? @ret : $ret[0];
  }
  
  ######################################################################
  # the real workhorse
  #
  sub _multi_expect($$@) {
    my $timeout = shift;
    my $timeout_hook = shift;
  
    if ($timeout_hook) {
      croak "Unknown timeout_hook type $timeout_hook"
        unless (ref($timeout_hook) eq 'CODE' 
  	      or ref($timeout_hook) eq 'ARRAY');
    }
  
    foreach my $pat (@_) {
      my @patterns = @{$pat}[1..$#{$pat}];
      foreach my $exp (@{$pat->[0]}) {
        ${*$exp}{exp_New_Data} = 1; # first round we always try to match
        if (exists ${*$exp}{"exp_Max_Accum"} and ${*$exp}{"exp_Max_Accum"}) {
  	${*$exp}{exp_Accum} =
  	  $exp->_trim_length(${*$exp}{exp_Accum},
  			     ${*$exp}{exp_Max_Accum});
        }
        print STDERR ("${*$exp}{exp_Pty_Handle}: beginning expect.\r\n",
  		    "\tTimeout: ",
  		    (defined($timeout) ? $timeout : "unlimited" ),
  		    " seconds.\r\n",
  		    "\tCurrent time: ". localtime(). "\r\n",
  		   ) if $Expect::Debug;
  
        # What are we expecting? What do you expect? :-)
        if (${*$exp}{exp_Exp_Internal}) {
  	print STDERR "${*$exp}{exp_Pty_Handle}: list of patterns:\r\n";
  	foreach my $pattern (@patterns) {
  	  print STDERR ('  ',
  			defined($pattern->[0])?
  			'#'. $pattern->[0].': ' :
  			'',
  			$pattern->[1],
  			" `", _make_readable($pattern->[2]),
  			"'\r\n");
  	}
  	print STDERR "\r\n";
        }
      }
    }
  
    my $successful_pattern;
    my $exp_matched;
    my $err;
    my $before;
    my $after;
    my $match;
    my @matchlist;
  
    # Set the last loop time to now for time comparisons at end of loop.
    my $start_loop_time = time();
    my $exp_cont = 1;
  
   READLOOP:
    while ($exp_cont) {
      $exp_cont = 1;
      $err = "";
      my $rmask = '';
      my $time_left = undef;
      if (defined $timeout) {
        $time_left = $timeout - (time() - $start_loop_time);
        $time_left = 0 if $time_left < 0;
      }
  
      $exp_matched = undef;
      # Test for a match first so we can test the current Accum w/out 
      # worrying about an EOF.
  
      foreach my $pat (@_) {
        my @patterns = @{$pat}[1..$#{$pat}];
        foreach my $exp (@{$pat->[0]}) {
  	# build mask for select in next section...
  	my $fn = $exp->fileno();
  	vec($rmask, $fn, 1) = 1 if defined $fn;
  
  	next unless ${*$exp}{exp_New_Data};
  
  	# clear error status
  	${*$exp}{exp_Error} = undef;
  
  	# This could be huge. We should attempt to do something
  	# about this.  Because the output is used for debugging
  	# I'm of the opinion that showing smaller amounts if the
  	# total is huge should be ok.
  	# Thus the 'trim_length'
  	print STDERR ("\r\n${*$exp}{exp_Pty_Handle}: Does `",
  		      $exp->_trim_length(_make_readable(${*$exp}{exp_Accum})),
  		      "'\r\nmatch:\r\n")
  	  if ${*$exp}{exp_Exp_Internal};
  
  	# we don't keep the parameter number anymore
  	# (clashes with before & after), instead the parameter number is
  	# stored inside the pattern; we keep the pattern ref
  	# and look up the number later.
  	foreach my $pattern (@patterns) {
  	  print STDERR ("  pattern",
  			defined($pattern->[0])? ' #' . $pattern->[0] : '',
  			": ", $pattern->[1],
  			" `", _make_readable($pattern->[2]),
  			"'? ")
  	    if (${*$exp}{exp_Exp_Internal});
  
  	  # Matching exactly
  	  if ($pattern->[1] eq '-ex') {
  	    my $match_index = index(${*$exp}{exp_Accum},
  				    $pattern->[2]);
  
  	    # We matched if $match_index > -1
  	    if ($match_index > -1) {
  	      $before = substr(${*$exp}{exp_Accum}, 0, $match_index);
  	      $match  = substr(${*$exp}{exp_Accum}, $match_index,
  			       length($pattern->[2]));
  	      $after  = substr(${*$exp}{exp_Accum},
  			       $match_index + length($pattern->[2])) ;
  	      ${*$exp}{exp_Before} = $before;
  	      ${*$exp}{exp_Match} = $match;
  	      ${*$exp}{exp_After} = $after;
  	      ${*$exp}{exp_Match_Number} = $pattern->[0];
  	      $exp_matched = $exp;
  	    }
  	  } elsif ($pattern->[1] eq '-re') {
  	    # m// in array context promises to return an empty list
  	    # but doesn't if the pattern doesn't contain brackets (),
  	    # so we kludge around by adding an empty bracket
  	    # at the end.
  
  	    if ($Expect::Multiline_Matching) {
  	      @matchlist = (${*$exp}{exp_Accum}
  			    =~ m/$pattern->[2]()/m);
  	      ($match, $before, $after) = ($&, $`, $');
  	    } else {
  	      @matchlist = (${*$exp}{exp_Accum}
  			    =~ m/$pattern->[2]()/);
  	      ($match, $before, $after) = ($&, $`, $');
  	    }
  	    if (@matchlist) {
  	      # Matching regexp
  	      ${*$exp}{exp_Before} = $before;
  	      ${*$exp}{exp_Match}  = $match;
  	      ${*$exp}{exp_After}  = $after;
  	      pop @matchlist;	# remove kludged empty bracket from end
  	      @{${*$exp}{exp_Matchlist}} = @matchlist;
  	      ${*$exp}{exp_Match_Number} = $pattern->[0];
  	      $exp_matched = $exp;
  	    }
  	  } else {
  	    # 'timeout' or 'eof'
  	  }
  
  	  if ($exp_matched) {
  	    ${*$exp}{exp_Accum} = $after
  	      unless ${*$exp}{exp_NoTransfer};
  	    print STDERR "YES!!\r\n"
  	      if ${*$exp}{exp_Exp_Internal};
  	    print STDERR ("    Before match string: `",
  			  $exp->_trim_length(_make_readable(($before))),
  			  "'\r\n",
  			  "    Match string: `", _make_readable($match),
  			  "'\r\n",
  			  "    After match string: `",
  			  $exp->_trim_length(_make_readable(($after))),
  			  "'\r\n",
  			  "    Matchlist: (",
  			  join(",  ",
  			       map { "`".$exp->_trim_length(_make_readable(($_)))."'"
  				   } @matchlist,
  			       ),
  			  ")\r\n",
  			 ) if (${*$exp}{exp_Exp_Internal});
  
  	    # call hook function if defined
  	    if ($pattern->[3]) {
  	      print STDERR ("Calling hook $pattern->[3]...\r\n",
  			   ) if (${*$exp}{exp_Exp_Internal} or $Expect::Debug);
  	      if ($#{$pattern} > 3) {
  		# call with parameters if given
  		$exp_cont = &{$pattern->[3]}($exp,
  					     @{$pattern}[4..$#{$pattern}]);
  	      } else {
  		$exp_cont = &{$pattern->[3]}($exp);
  	      }
  	    }
  	    if ($exp_cont and $exp_cont eq exp_continue) {
  	      print STDERR ("Continuing expect, restarting timeout...\r\n")
  		if (${*$exp}{exp_Exp_Internal} or $Expect::Debug);
  	      $start_loop_time = time(); # restart timeout count
  	      next READLOOP;
  	    } elsif ($exp_cont and $exp_cont eq exp_continue_timeout) {
  	      print STDERR ("Continuing expect...\r\n")
  		if (${*$exp}{exp_Exp_Internal} or $Expect::Debug);
  	      next READLOOP;
  	    }
  	    last READLOOP;
  	  }
  	  print STDERR "No.\r\n" if ${*$exp}{exp_Exp_Internal};
  	}
  	print STDERR "\r\n" if ${*$exp}{exp_Exp_Internal};
  	# don't have to match again until we get new data
  	${*$exp}{exp_New_Data} = 0;
        }
      } # End of matching section
  
      # No match, let's see what is pending on the filehandles...
      print STDERR ("Waiting for new data (",
  		  defined($time_left)? $time_left : 'unlimited',
  		  " seconds)...\r\n",
  		 ) if ($Expect::Exp_Internal or $Expect::Debug);
      my $nfound;
    SELECT: {
        $nfound = select($rmask, undef, undef, $time_left);
        if ($nfound < 0) {
  	if ($!{EINTR} and $Expect::IgnoreEintr) {
  	  print STDERR ("ignoring EINTR, restarting select()...\r\n")
  	    if ($Expect::Exp_Internal or $Expect::Debug);
  	  next SELECT;
  	}
  	print STDERR ("select() returned error code '$!'\r\n")
  	  if ($Expect::Exp_Internal or $Expect::Debug);
  	# returned error
  	$err = "4:$!";
  	last READLOOP;
        }
      }
      # go until we don't find something (== timeout).
      if ($nfound == 0) {
        # No pattern, no EOF. Did we time out?
        $err = "1:TIMEOUT";
        foreach my $pat (@_) {
  	foreach my $exp (@{$pat->[0]}) {
  	  $before = ${*$exp}{exp_Before} = ${*$exp}{exp_Accum};
  	  next if not defined $exp->fileno(); # skip already closed
  	  ${*$exp}{exp_Error} = $err unless ${*$exp}{exp_Error};
  	}
        }
        print STDERR ("TIMEOUT\r\n")
  	if ($Expect::Debug or $Expect::Exp_Internal);
        if ($timeout_hook) {
  	my $ret;
  	print STDERR ("Calling timeout function $timeout_hook...\r\n")
  	  if ($Expect::Debug or $Expect::Exp_Internal);
  	if (ref($timeout_hook) eq 'CODE') {
  	  $ret = &{$timeout_hook}($_[0]->[0]);
  	} else {
  	  if ($#{$timeout_hook} > 3) {
  	    $ret = &{$timeout_hook->[3]}($_[0]->[0],
  					 @{$timeout_hook}[4..$#{$timeout_hook}]);
  	  } else {
  	    $ret = &{$timeout_hook->[3]}($_[0]->[0]);
  	  }
  	}
  	if ($ret and $ret eq exp_continue) {
  	  $start_loop_time = time();	# restart timeout count
  	  next READLOOP;
  	}
        }
        last READLOOP;
      }
  
      my @bits = split(//,unpack('b*',$rmask));
      foreach my $pat (@_) {
        foreach my $exp (@{$pat->[0]}) {
  	next if not defined $exp->fileno(); # skip already closed
  	if ($bits[$exp->fileno()]) {
  	  print STDERR ("${*$exp}{exp_Pty_Handle}: new data.\r\n")
  	    if $Expect::Debug;
  	  # read in what we found.
  	  my $buffer;
  	  my $nread = sysread($exp, $buffer, 2048);
  
  	  # Make errors (nread undef) show up as EOF.
  	  $nread = 0 unless defined ($nread);
  
  	  if ($nread == 0) {
  	    print STDERR ("${*$exp}{exp_Pty_Handle}: EOF\r\n")
  	      if ($Expect::Debug);
  	    $before = ${*$exp}{exp_Before} = $exp->clear_accum();
  	    $err = "2:EOF";
  	    ${*$exp}{exp_Error} = $err;
  	    ${*$exp}{exp_Has_EOF} = 1;
  	    $exp_cont = undef;
  	    foreach my $eof_pat (grep {$_->[1] eq '-eof'} @{$pat}[1..$#{$pat}]) {
  	      my $ret;
  	      print STDERR ("Calling EOF hook $eof_pat->[3]...\r\n",
  			   ) if ($Expect::Debug);
  	      if ($#{$eof_pat} > 3) {
  		# call with parameters if given
  		$ret = &{$eof_pat->[3]}($exp,
  					@{$eof_pat}[4..$#{$eof_pat}]);
  	      } else {
  		$ret = &{$eof_pat->[3]}($exp);
  	      }
  	      if ($ret and
  		  ($ret eq exp_continue
  		   or $ret eq exp_continue_timeout)) {
  		    $exp_cont = $ret;
  	      }
  	    }
  	    # is it dead?
  	    if (defined(${*$exp}{exp_Pid})) {
  	      my $ret = waitpid(${*$exp}{exp_Pid}, POSIX::WNOHANG);
  	      if ($ret == ${*$exp}{exp_Pid}) {
  		printf STDERR ("%s: exit(0x%02X)\r\n", 
  			       ${*$exp}{exp_Pty_Handle}, $?)
  		  if ($Expect::Debug);
  		$err = "3:Child PID ${*$exp}{exp_Pid} exited with status $?";
  		${*$exp}{exp_Error} = $err;
  		${*$exp}{exp_Exit} = $?;
  		delete $Expect::Spawned_PIDs{${*$exp}{exp_Pid}};
  		${*$exp}{exp_Pid} = undef;
  	      }
  	    }
  	    print STDERR ("${*$exp}{exp_Pty_Handle}: closing...\r\n")
  	      if ($Expect::Debug);
  	    $exp->hard_close();
  	    next;
  	  }
  	  print STDERR ("${*$exp}{exp_Pty_Handle}: read $nread byte(s).\r\n")
  	    if ($Expect::Debug);
  
  	  # ugly hack for broken solaris ttys that spew <blank><backspace>
  	  # into our pretty output
  	  $buffer =~ s/ \cH//g if not ${*$exp}{exp_Raw_Pty};
  	  # Append it to the accumulator.
  	  ${*$exp}{exp_Accum} .= $buffer;
  	  if (exists ${*$exp}{exp_Max_Accum}
  	      and ${*$exp}{exp_Max_Accum}) {
  	    ${*$exp}{exp_Accum} =
  	      $exp->_trim_length(${*$exp}{exp_Accum},
  				 ${*$exp}{exp_Max_Accum});
  	  }
  	  ${*$exp}{exp_New_Data} = 1; # next round we try to match again
  
  	  $exp_cont = exp_continue
  	    if (exists ${*$exp}{exp_Continue} and ${*$exp}{exp_Continue});
  	  # Now propagate what we have read to other listeners...
  	  $exp->_print_handles($buffer);
  
  	  # End handle reading section.
  	}
        }
      }				# end read loop
      $start_loop_time = time()	# restart timeout count
        if ($exp_cont and $exp_cont eq exp_continue);
    }
    # End READLOOP
  
    # Post loop. Do we have anything?
    # Tell us status
    if ($Expect::Debug or $Expect::Exp_Internal) {
        if ($exp_matched) {
  	  print STDERR ("Returning from expect ",
  			${*$exp_matched}{exp_Error} ? 'un' : '',
  			"successfully.",
  			${*$exp_matched}{exp_Error} ?
  			"\r\n  Error: ${*$exp_matched}{exp_Error}." : '',
  			"\r\n");
        } else {
  	  print STDERR ("Returning from expect with TIMEOUT or EOF\r\n");
        }
      if ($Expect::Debug and $exp_matched) {
        print STDERR "  ${*$exp_matched}{exp_Pty_Handle}: accumulator: `";
        if (${*$exp_matched}{exp_Error}) {
  	print STDERR ($exp_matched->_trim_length
  		      (_make_readable(${*$exp_matched}{exp_Before})),
  		      "'\r\n");
        } else {
  	print STDERR ($exp_matched->_trim_length
  		      (_make_readable(${*$exp_matched}{exp_Accum})),
  		      "'\r\n");
        }
      }
    }
  
    if ($exp_matched) {
      return wantarray?
        (${*$exp_matched}{exp_Match_Number},
         ${*$exp_matched}{exp_Error},
         ${*$exp_matched}{exp_Match},
         ${*$exp_matched}{exp_Before},
         ${*$exp_matched}{exp_After},
         $exp_matched,
        ) :
  	${*$exp_matched}{exp_Match_Number};
    }
  
    return wantarray? (undef, $err, undef, $before, undef, undef) : undef;
  }
  
  
  # Patterns are arrays that consist of
  # [ $pattern_type, $pattern, $sub, @subparms ]
  # optional $pattern_type is '-re' (RegExp, default) or '-ex' (exact);
  # $sub is optional CODE ref, which is called as &{$sub}($exp, @subparms)
  #   if pattern matched;
  # the $parm_nr gets unshifted onto the array for reporting purposes.
  
  sub _add_patterns_to_list($$$@) {
    my $listref = shift;
    my $timeoutlistref = shift;	# gets timeout patterns
    my $store_parm_nr = shift;
    my $parm_nr = $store_parm_nr || 1;
    foreach my $parm (@_) {
      if (not ref($parm) eq 'ARRAY') {
        return "Parameter #$parm_nr is not an ARRAY ref.";
      }
      $parm = [@$parm];		# make copy
      if ($parm->[0] =~ m/\A-/) {
        # it's an option
        if ($parm->[0] ne '-re'
  	  and $parm->[0] ne '-ex') {
  	return "Unknown option $parm->[0] in pattern #$parm_nr";
        }
      } else {
        if ($parm->[0] eq 'timeout') {
  	if (defined $timeoutlistref) {
  	  splice @$parm, 0, 1, ("-$parm->[0]", undef);
  	  unshift @$parm, $store_parm_nr? $parm_nr: undef;
  	  push @$timeoutlistref, $parm;
  	}
  	next;
        } elsif ($parm->[0] eq 'eof') {
  	splice @$parm, 0, 1, ("-$parm->[0]", undef);
        } else {
  	unshift @$parm, '-re';	# defaults to RegExp
        }
      }
      if (@$parm > 2) {
        if (ref($parm->[2]) ne 'CODE') {
  	croak ("Pattern #$parm_nr doesn't have a CODE reference",
  	       "after the pattern.");
        }
      } else {
        push @$parm, undef;	# make sure we have three elements
      }
  
      unshift @$parm, $store_parm_nr? $parm_nr: undef;
      push @$listref, $parm;
      $parm_nr++
    }
    return undef;
  }
  
  ######################################################################
  # $process->interact([$in_handle],[$escape sequence])
  # If you don't specify in_handle STDIN  will be used.
  sub interact {
    my ($self) = (shift);
    my ($infile) = (shift);
    my ($escape_sequence) = shift;
    my ($in_object,$in_handle,@old_group,$return_value);
    my ($old_manual_stty_val,$old_log_stdout_val);
    my ($outfile,$out_object);
    @old_group = $self->set_group();
    # If the handle is STDIN we'll
    # $infile->fileno == 0 should be stdin.. follow stdin rules.
    no strict 'subs';		# Allow bare word 'STDIN'
    unless (defined($infile)) {
      # We need a handle object Associated with STDIN.
      $infile = new IO::File;
      $infile->IO::File::fdopen(STDIN,'r');
      $outfile = new IO::File;
      $outfile->IO::File::fdopen(STDOUT,'w');
    } elsif (fileno($infile) == fileno(STDIN)) {
      # With STDIN we want output to go to stdout.
      $outfile = new IO::File;
      $outfile->IO::File::fdopen(STDOUT,'w');
    } else {
      undef ($outfile);
    }
    # Here we assure ourselves we have an Expect object.
    $in_object = Expect->exp_init($infile);
    if (defined($outfile)) {
      # as above.. we want output to go to stdout if we're given stdin.
      $out_object = Expect->exp_init($outfile);
      $out_object->manual_stty(1);
      $self->set_group($out_object);
    } else {
      $self->set_group($in_object);
    }
    $in_object->set_group($self);
    $in_object->set_seq($escape_sequence,undef) if defined($escape_sequence);
    # interconnect normally sets stty -echo raw. Interact really sort
    # of implies we don't do that by default. If anyone wanted to they could
    # set it before calling interact, of use interconnect directly.
    $old_manual_stty_val = $self->manual_stty();
    $self->manual_stty(1);
    # I think this is right. Don't send stuff from in_obj to stdout by default.
    # in theory whatever 'self' is should echo what's going on.
    $old_log_stdout_val = $self->log_stdout();
    $self->log_stdout(0);
    $in_object->log_stdout(0);
    # Allow for the setting of an optional EOF escape function.
    #  $in_object->set_seq('EOF',undef);
    #  $self->set_seq('EOF',undef);
    Expect::interconnect($self,$in_object);
    $self->log_stdout($old_log_stdout_val);
    $self->set_group(@old_group);
    # If old_group was undef, make sure that occurs. This is a slight hack since
    # it modifies the value directly.
    # Normally an undef passed to set_group will return the current groups.
    # It is possible that it may be of worth to make it possible to undef
    # The current group without doing this.
    unless (@old_group) {
      @{${*$self}{exp_Listen_Group}} = ();
    }
    $self->manual_stty($old_manual_stty_val);
    return $return_value;
  }
  
  sub interconnect {
  
    #  my ($handle)=(shift); call as Expect::interconnect($spawn1,$spawn2,...)
    my ($rmask,$nfound,$nread);
    my ($rout, @bits, $emask, $eout, @ebits ) = ();
    my ($escape_sequence,$escape_character_buffer);
    my (@handles) = @_;
    my ($handle,$read_handle,$write_handle);
    my ($read_mask,$temp_mask) = ('','');
  
    # Get read/write handles
    foreach $handle (@handles) {
      $temp_mask = '';
      vec($temp_mask,$handle->fileno(),1) = 1;
      # Under Linux w/ 5.001 the next line comes up w/ 'Uninit var.'.
      # It appears to be impossible to make the warning go away.
      # doing something like $temp_mask='' unless defined ($temp_mask)
      # has no effect whatsoever. This may be a bug in 5.001.
      $read_mask = $read_mask | $temp_mask;
    }
    if ($Expect::Debug) {
      print STDERR "Read handles:\r\n";
      foreach $handle (@handles) {
        print STDERR "\tRead handle: ";
        print STDERR "'${*$handle}{exp_Pty_Handle}'\r\n";
        print STDERR "\t\tListen Handles:";
        foreach $write_handle (@{${*$handle}{exp_Listen_Group}}) {
  	print STDERR " '${*$write_handle}{exp_Pty_Handle}'";
        }
        print STDERR ".\r\n";
      }
    }
  
    #  I think if we don't set raw/-echo here we may have trouble. We don't
    # want a bunch of echoing crap making all the handles jabber at each other.
    foreach $handle (@handles) {
      unless (${*$handle}{"exp_Manual_Stty"}) {
        # This is probably O/S specific.
        ${*$handle}{exp_Stored_Stty} = $handle->exp_stty('-g');
        print STDERR "Setting tty for ${*$handle}{exp_Pty_Handle} to 'raw -echo'.\r\n"if ${*$handle}{"exp_Debug"};
        $handle->exp_stty("raw -echo");
      }
      foreach $write_handle (@{${*$handle}{exp_Listen_Group}}) {
        unless (${*$write_handle}{"exp_Manual_Stty"}) {
  	${*$write_handle}{exp_Stored_Stty} = $write_handle->exp_stty('-g');
  	print STDERR "Setting ${*$write_handle}{exp_Pty_Handle} to 'raw -echo'.\r\n"if ${*$handle}{"exp_Debug"};
  	$write_handle->exp_stty("raw -echo");
        }
      }
    }
  
    print STDERR "Attempting interconnection\r\n" if $Expect::Debug;
  
    # Wait until the process dies or we get EOF
    # In the case of !${*$handle}{exp_Pid} it means
    # the handle was exp_inited instead of spawned.
   CONNECT_LOOP:
    # Go until we have a reason to stop
    while (1) {
      # test each handle to see if it's still alive.
      foreach $read_handle (@handles) {
        waitpid(${*$read_handle}{exp_Pid}, WNOHANG)
  	if (exists (${*$read_handle}{exp_Pid}) and ${*$read_handle}{exp_Pid});
        if (exists(${*$read_handle}{exp_Pid})
  	  and (${*$read_handle}{exp_Pid})
  	  and (! kill(0,${*$read_handle}{exp_Pid}))) {
  	print STDERR "Got EOF (${*$read_handle}{exp_Pty_Handle} died) reading ${*$read_handle}{exp_Pty_Handle}\r\n"
  	  if ${*$read_handle}{"exp_Debug"};
  	last CONNECT_LOOP unless defined(${${*$read_handle}{exp_Function}}{"EOF"});
  	last CONNECT_LOOP unless &{${${*$read_handle}{exp_Function}}{"EOF"}}(@{${${*$read_handle}{exp_Parameters}}{"EOF"}});
        }
      }
  
      # Every second? No, go until we get something from someone.
      ($nfound) = select($rout = $read_mask, undef, $eout = $emask, undef);
      # Is there anything to share?  May be -1 if interrupted by a signal...
      next CONNECT_LOOP if not defined $nfound or $nfound < 1;
      # Which handles have stuff?
      @bits = split(//,unpack('b*',$rout));
      $eout = 0 unless defined ($eout);
      @ebits = split(//,unpack('b*',$eout));
      #    print "Ebits: $eout\r\n";
      foreach $read_handle (@handles) {
        if ($bits[$read_handle->fileno()]) {
  	$nread = sysread( $read_handle, ${*$read_handle}{exp_Pty_Buffer}, 1024 );
  	# Appease perl -w
  	$nread = 0 unless defined ($nread);
  	print STDERR "interconnect: read $nread byte(s) from ${*$read_handle}{exp_Pty_Handle}.\r\n" if ${*$read_handle}{"exp_Debug"} > 1;
  	# Test for escape seq. before printing.
  	# Appease perl -w
  	$escape_character_buffer = '' unless defined ($escape_character_buffer);
  	$escape_character_buffer .= ${*$read_handle}{exp_Pty_Buffer};
  	foreach $escape_sequence (keys(%{${*$read_handle}{exp_Function}})) {
  	  print STDERR "Tested escape sequence $escape_sequence from ${*$read_handle}{exp_Pty_Handle}"if ${*$read_handle}{"exp_Debug"} > 1;
  	  # Make sure it doesn't grow out of bounds.
  	  $escape_character_buffer = $read_handle->_trim_length($escape_character_buffer,${*$read_handle}{"exp_Max_Accum"}) if (${*$read_handle}{"exp_Max_Accum"});
  	  if ($escape_character_buffer =~ /($escape_sequence)/) {
  	    if (${*$read_handle}{"exp_Debug"}) {
  	      print STDERR "\r\ninterconnect got escape sequence from ${*$read_handle}{exp_Pty_Handle}.\r\n";
  	      # I'm going to make the esc. seq. pretty because it will 
  	      # probably contain unprintable characters.
  	      print STDERR "\tEscape Sequence: '"._trim_length(undef,_make_readable($escape_sequence))."'\r\n";
  	      print STDERR "\tMatched by string: '"._trim_length(undef,_make_readable($&))."'\r\n";
  	    }
  	    # Print out stuff before the escape.
  	    # Keep in mind that the sequence may have been split up
  	    # over several reads.
  	    # Let's get rid of it from this read. If part of it was 
  	    # in the last read there's not a lot we can do about it now.
  	    if (${*$read_handle}{exp_Pty_Buffer} =~ /($escape_sequence)/) {
  	      $read_handle->_print_handles($`);
  	    } else {
  	      $read_handle->_print_handles(${*$read_handle}{exp_Pty_Buffer})
  	    }
  	    # Clear the buffer so no more matches can be made and it will
  	    # only be printed one time.
  	    ${*$read_handle}{exp_Pty_Buffer} = '';
  	    $escape_character_buffer = '';
  	    # Do the function here. Must return non-zero to continue.
  	    # More cool syntax. Maybe I should turn these in to objects.
  	    last CONNECT_LOOP unless &{${${*$read_handle}{exp_Function}}{$escape_sequence}}(@{${${*$read_handle}{exp_Parameters}}{$escape_sequence}});
  	  }
  	}
  	$nread = 0 unless defined($nread); # Appease perl -w?
  	waitpid(${*$read_handle}{exp_Pid}, WNOHANG) if (defined (${*$read_handle}{exp_Pid}) &&${*$read_handle}{exp_Pid});
  	if ($nread == 0) {
  	  print STDERR "Got EOF reading ${*$read_handle}{exp_Pty_Handle}\r\n"if ${*$read_handle}{"exp_Debug"}; 
  	  last CONNECT_LOOP unless defined(${${*$read_handle}{exp_Function}}{"EOF"});
  	  last CONNECT_LOOP unless &{${${*$read_handle}{exp_Function}}{"EOF"}}(@{${${*$read_handle}{exp_Parameters}}{"EOF"}});
  	}
  	last CONNECT_LOOP if ($nread < 0); # This would be an error
  	$read_handle->_print_handles(${*$read_handle}{exp_Pty_Buffer});
        }
        # I'm removing this because I haven't determined what causes exceptions
        # consistently.
        if (0)			#$ebits[$read_handle->fileno()])
  	{
  	  print STDERR "Got Exception reading ${*$read_handle}{exp_Pty_Handle}\r\n"if ${*$read_handle}{"exp_Debug"};
  	  last CONNECT_LOOP unless defined(${${*$read_handle}{exp_Function}}{"EOF"});
  	  last CONNECT_LOOP unless &{${${*$read_handle}{exp_Function}}{"EOF"}}(@{${${*$read_handle}{exp_Parameters}}{"EOF"}});
  	}
      }
    }
    foreach $handle (@handles) {
      unless (${*$handle}{"exp_Manual_Stty"}) {
        $handle->exp_stty(${*$handle}{exp_Stored_Stty});
      }
      foreach $write_handle (@{${*$handle}{exp_Listen_Group}}) {
        unless (${*$write_handle}{"exp_Manual_Stty"}) {
  	$write_handle->exp_stty(${*$write_handle}{exp_Stored_Stty});
        }
      }
    }
  }
  
  # user can decide if log output gets also sent to logfile
  sub print_log_file {
    my $self = shift;
    if (${*$self}{exp_Log_File}) {
      if (ref(${*$self}{exp_Log_File}) eq 'CODE') {
        ${*$self}{exp_Log_File}->(@_);
      } else {
        ${*$self}{exp_Log_File}->print(@_);
      }
    }
  }
  
  # we provide our own print so we can debug what gets sent to the
  # processes...
  sub print (@) {
    my ($self, @args) = @_;
    return if not defined $self->fileno(); # skip if closed
    if (${*$self}{exp_Exp_Internal}) {
      my $args = _make_readable(join('', @args));
      cluck "Sending '$args' to ${*$self}{exp_Pty_Handle}\r\n";
    }
    foreach my $arg (@args) {
      while (length($arg) > 80) {
        $self->SUPER::print(substr($arg, 0, 80));
        $arg = substr($arg, 80);
      }
      $self->SUPER::print($arg);
    }
  }
  
  # make an alias for Tcl/Expect users for a DWIM experience...
  *send = \&print;
  
  # This is an Expect standard. It's nice for talking to modems and the like
  # where from time to time they get unhappy if you send items too quickly.
  sub send_slow{
    my ($self) = shift;
    my($char,@linechars,$nfound,$rmask);
    return if not defined $self->fileno(); # skip if closed
    my($sleep_time) = shift;
    # Flushing makes it so each character can be seen separately.
    my $chunk;
    while ($chunk = shift) {
      @linechars = split ('', $chunk);
      foreach $char (@linechars) {
        #     How slow?
        select (undef,undef,undef,$sleep_time);
  
        print $self $char;
        print STDERR "Printed character \'"._make_readable($char)."\' to ${*$self}{exp_Pty_Handle}.\r\n" if ${*$self}{"exp_Debug"} > 1;
        # I think I can get away with this if I save it in accum
        if (${*$self}{"exp_Log_Stdout"} ||${*$self}{exp_Log_Group}) {
  	$rmask = "";
  	vec($rmask,$self->fileno(),1) = 1;
  	# .01 sec granularity should work. If we miss something it will
  	# probably get flushed later, maybe in an expect call.
  	while (select($rmask,undef,undef,.01)) {
  	  my $ret = sysread($self,${*$self}{exp_Pty_Buffer},1024);
  	  last if not defined $ret or $ret == 0;
  	  # Is this necessary to keep? Probably.. #
  	  # if you need to expect it later.
  	  ${*$self}{exp_Accum}.= ${*$self}{exp_Pty_Buffer};
  	  ${*$self}{exp_Accum} = $self->_trim_length(${*$self}{exp_Accum},${*$self}{"exp_Max_Accum"}) if (${*$self}{"exp_Max_Accum"});
  	  $self->_print_handles(${*$self}{exp_Pty_Buffer});
  	  print STDERR "Received \'".$self->_trim_length(_make_readable($char))."\' from ${*$self}{exp_Pty_Handle}\r\n" if ${*$self}{"exp_Debug"} > 1;
  	}
        }
      }
    }
  }
  
  sub test_handles {
    # This should be called by Expect::test_handles($timeout,@objects);
    my ($rmask, $allmask, $rout, $nfound, @bits);
    my ($timeout) = shift;
    my (@handle_list) = @_;
    my($handle);
    foreach $handle (@handle_list) {
      $rmask = '';
      vec($rmask,$handle->fileno(),1) = 1;
      $allmask = '' unless defined ($allmask);
      $allmask = $allmask | $rmask;
    }
    ($nfound) = select($rout = $allmask, undef, undef, $timeout);
    return () unless $nfound;
    # Which handles have stuff?
    @bits = split(//,unpack('b*',$rout));
  
    my $handle_num = 0;
    my @return_list = ();
    foreach $handle (@handle_list) {
      # I go to great lengths to get perl -w to shut the hell up.
      if (defined($bits[$handle->fileno()]) and ($bits[$handle->fileno()])) {
        push(@return_list,$handle_num);
      }
    } continue {
      $handle_num++;
    }
      return (@return_list);
  }
  
  # Be nice close. This should emulate what an interactive shell does after a
  # command finishes... sort of. We're not as patient as a shell.
  sub soft_close {
    my($self) = shift;
    my($nfound,$nread,$rmask,$returned_pid);
    my($end_time,$select_time,$temp_buffer);
    my($close_status);
    # Give it 15 seconds to cough up an eof.
    cluck "Closing ${*$self}{exp_Pty_Handle}.\r\n" if ${*$self}{exp_Debug};
    return -1 if not defined $self->fileno(); # skip if handle already closed
    unless (exists ${*$self}{exp_Has_EOF} and ${*$self}{exp_Has_EOF}) {
      $end_time = time() + 15;
      while ($end_time > time()) {
        $select_time = $end_time - time();
        # Sanity check.
        $select_time = 0 if $select_time < 0;
        $rmask = '';
        vec($rmask,$self->fileno(),1) = 1;
        ($nfound) = select($rmask,undef,undef,$select_time);
        last unless (defined($nfound) && $nfound);
        $nread = sysread($self,$temp_buffer,8096);
        # 0 = EOF.
        unless (defined($nread) && $nread) {
  	print STDERR "Got EOF from ${*$self}{exp_Pty_Handle}.\r\n" if ${*$self}{exp_Debug};
  	last;
        }
        $self->_print_handles($temp_buffer);
      }
      if (($end_time <= time()) && ${*$self}{exp_Debug}) {
        print STDERR "Timed out waiting for an EOF from ${*$self}{exp_Pty_Handle}.\r\n";
      }
    }
    if ( ($close_status = $self->close()) && ${*$self}{exp_Debug}) {
      print STDERR "${*$self}{exp_Pty_Handle} closed.\r\n";
    }
    # quit now if it isn't a process.
    return $close_status unless defined(${*$self}{exp_Pid});
    # Now give it 15 seconds to die.
    $end_time = time() + 15;
    while ($end_time > time()) {
      $returned_pid = waitpid(${*$self}{exp_Pid}, &WNOHANG);
      # Stop here if the process dies.
      if (defined($returned_pid) && $returned_pid) {
        delete $Expect::Spawned_PIDs{$returned_pid};
        if (${*$self}{exp_Debug}) {
  	printf STDERR ("Pid %d of %s exited, Status: 0x%02X\r\n",
  		       ${*$self}{exp_Pid}, ${*$self}{exp_Pty_Handle}, $?);
        }
        ${*$self}{exp_Pid} = undef;
        ${*$self}{exp_Exit} = $?;
        return ${*$self}{exp_Exit};
      }
      sleep 1;			# Keep loop nice.
    }
    # Send it a term if it isn't dead.
    if (${*$self}{exp_Debug}) {
      print STDERR "${*$self}{exp_Pty_Handle} not exiting, sending TERM.\r\n";
    }
    kill TERM => ${*$self}{exp_Pid};
    # Now to be anal retentive.. wait 15 more seconds for it to die.
    $end_time = time() + 15;
    while ($end_time > time()) {
      $returned_pid = waitpid(${*$self}{exp_Pid}, &WNOHANG);
      if (defined($returned_pid) && $returned_pid) {
        delete $Expect::Spawned_PIDs{$returned_pid};
        if (${*$self}{exp_Debug}) {
  	printf STDERR ("Pid %d of %s terminated, Status: 0x%02X\r\n",
  		       ${*$self}{exp_Pid}, ${*$self}{exp_Pty_Handle}, $?);
        }
        ${*$self}{exp_Pid} = undef;
        ${*$self}{exp_Exit} = $?;
        return $?;
      }
      sleep 1;
    }
    # Since this is a 'soft' close, sending it a -9 would be inappropriate.
    return undef;
  }
  
  # 'Make it go away' close.
  sub hard_close {
    my($self) = shift;
    my($nfound,$nread,$rmask,$returned_pid);
    my($end_time,$select_time,$temp_buffer);
    my($close_status);
    cluck "Closing ${*$self}{exp_Pty_Handle}.\r\n" if ${*$self}{exp_Debug};
    # Don't wait for an EOF.
    if ( ($close_status = $self->close()) && ${*$self}{exp_Debug}) {
      print STDERR "${*$self}{exp_Pty_Handle} closed.\r\n";
    }
    # Return now if handle.
    return $close_status unless defined(${*$self}{exp_Pid});
    # Now give it 5 seconds to die. Less patience here if it won't die.
    $end_time = time() + 5;
    while ($end_time > time()) {
      $returned_pid = waitpid(${*$self}{exp_Pid}, &WNOHANG);
      # Stop here if the process dies.
      if (defined($returned_pid) && $returned_pid) {
        delete $Expect::Spawned_PIDs{$returned_pid};
        if (${*$self}{exp_Debug}) {
  	printf STDERR ("Pid %d of %s terminated, Status: 0x%02X\r\n",
  		       ${*$self}{exp_Pid}, ${*$self}{exp_Pty_Handle}, $?);
        }
        ${*$self}{exp_Pid} = undef;
        ${*$self}{exp_Exit} = $?;
        return ${*$self}{exp_Exit};
      }
      sleep 1;			# Keep loop nice.
    }
    # Send it a term if it isn't dead.
    if (${*$self}{exp_Debug}) {
      print STDERR "${*$self}{exp_Pty_Handle} not exiting, sending TERM.\r\n";
    }
    kill TERM => ${*$self}{exp_Pid};
    # wait 15 more seconds for it to die.
    $end_time = time() + 15;
    while ($end_time > time()) {
      $returned_pid = waitpid(${*$self}{exp_Pid}, &WNOHANG);
      if (defined($returned_pid) && $returned_pid) {
        delete $Expect::Spawned_PIDs{$returned_pid};
        if (${*$self}{exp_Debug}) {
  	printf STDERR ("Pid %d of %s terminated, Status: 0x%02X\r\n",
  		       ${*$self}{exp_Pid}, ${*$self}{exp_Pty_Handle}, $?);
        }
        ${*$self}{exp_Pid} = undef;
        ${*$self}{exp_Exit} = $?;
        return ${*$self}{exp_Exit};
      }
      sleep 1;
    }
    kill KILL => ${*$self}{exp_Pid};
    # wait 5 more seconds for it to die.
    $end_time = time() + 5;
    while ($end_time > time()) {
      $returned_pid = waitpid(${*$self}{exp_Pid}, &WNOHANG);
      if (defined($returned_pid) && $returned_pid) {
        delete $Expect::Spawned_PIDs{$returned_pid};
        if (${*$self}{exp_Debug}) {
  	printf STDERR ("Pid %d of %s killed, Status: 0x%02X\r\n",
  		       ${*$self}{exp_Pid}, ${*$self}{exp_Pty_Handle}, $?);
        }
        ${*$self}{exp_Pid} = undef;
        ${*$self}{exp_Exit} = $?;
        return ${*$self}{exp_Exit};
      }
      sleep 1;
    }
    warn "Pid ${*$self}{exp_Pid} of ${*$self}{exp_Pty_Handle} is HUNG.\r\n";
    ${*$self}{exp_Pid} = undef;
    return undef;
  }
  
  # These should not be called externally.
  
  sub _init_vars {
    my($self) = shift;
  
    # for every spawned process or filehandle.
    ${*$self}{exp_Log_Stdout} = $Expect::Log_Stdout
      if defined ($Expect::Log_Stdout);
    ${*$self}{exp_Log_Group} = $Expect::Log_Group;
    ${*$self}{exp_Debug} = $Expect::Debug;
    ${*$self}{exp_Exp_Internal} = $Expect::Exp_Internal;
    ${*$self}{exp_Manual_Stty} = $Expect::Manual_Stty;
    ${*$self}{exp_Stored_Stty} = 'sane';
    ${*$self}{exp_Do_Soft_Close} = $Expect::Do_Soft_Close;
  
    # sysread doesn't like my or local vars.
    ${*$self}{exp_Pty_Buffer} = '';
  
    # Initialize accumulator.
    ${*$self}{exp_Max_Accum} = $Expect::Exp_Max_Accum;
    ${*$self}{exp_Accum} = '';
    ${*$self}{exp_NoTransfer} = 0;
  
    # create empty expect_before & after lists
    ${*$self}{exp_expect_before_list} = [];
    ${*$self}{exp_expect_after_list} = [];
  }
  
  
  sub _make_readable {
    my $s = shift;
    $s = '' if not defined ($s);
    study $s;		# Speed things up?
    $s =~ s/\\/\\\\/g;	# So we can tell easily(?) what is a backslash
    $s =~ s/\n/\\n/g;
    $s =~ s/\r/\\r/g;
    $s =~ s/\t/\\t/g;
    $s =~ s/\'/\\\'/g;	# So we can tell whassa quote and whassa notta quote.
    $s =~ s/\"/\\\"/g;
    # Formfeed (does anyone use formfeed?)
    $s =~ s/\f/\\f/g;
    $s =~ s/\010/\\b/g;
    # escape control chars high/low, but allow ISO 8859-1 chars
    $s =~ s/[\000-\037\177-\237\377]/sprintf("\\%03lo",ord($&))/ge;
  
    return $s;
  }
  
  sub _trim_length {
    # This is sort of a reverse truncation function
    # Mostly so we don't have to see the full output when we're using
    # Also used if Max_Accum gets set to limit the size of the accumulator
    # for matching functions.
    # exp_internal
    my($self) = shift;
    my($string) = shift;
    my($length) = shift;
  
    # If we're not passed a length (_trim_length is being used for debugging
    # purposes) AND debug >= 3, don't trim.
    return($string) if (defined ($self) and
  		      ${*$self}{"exp_Debug"} >= 3 and (!(defined($length))));
    my($indicate_truncation) = '...' unless $length;
    $length = 1021 unless $length;
    return($string) unless $length < length($string);
    # We wouldn't want the accumulator to begin with '...' if max_accum is passed
    # This is because this funct. gets called internally w/ max_accum
    # and is also used to print information back to the user.
    return $indicate_truncation.substr($string,(length($string) - $length),$length);
  }
  
  sub _print_handles {
    # Given crap from 'self' and the handles self wants to print to, print to
    # them. these are indicated by the handle's 'group'
    my($self) = shift;
    my($print_this) = shift;
    my($handle);
    if (${*$self}{exp_Log_Group}) {
      foreach $handle (@{${*$self}{exp_Listen_Group}}) {
        $print_this = '' unless defined ($print_this);
        # Appease perl -w
        print STDERR "Printed '".$self->_trim_length(_make_readable($print_this))."' to ${*$handle}{exp_Pty_Handle} from ${*$self}{exp_Pty_Handle}.\r\n" if (${*$handle}{"exp_Debug"} > 1);
        print $handle $print_this;
      }
    }
    # If ${*$self}{exp_Pty_Handle} is STDIN this would make it echo.
    print STDOUT $print_this
      if ${*$self}{"exp_Log_Stdout"};
    $self->print_log_file($print_this);
    $|= 1; # This should not be necessary but autoflush() doesn't always work.
  }
  
  sub _get_mode {
    my($fcntl_flags) = '';
    my($handle) = shift;
    # What mode are we opening with? use fcntl to find out.
    $fcntl_flags = fcntl(\*{$handle},Fcntl::F_GETFL,$fcntl_flags);
    die "fcntl returned undef during exp_init of $handle, $!\r\n" unless defined($fcntl_flags);
    if ($fcntl_flags | (Fcntl::O_RDWR)) {
      return 'rw';
    } elsif ($fcntl_flags | (Fcntl::O_WRONLY)) {
      return 'w'
    } else {
      # Under Solaris (among others?) O_RDONLY is implemented as 0. so |O_RDONLY would fail.
      return 'r';
    }
  }
  
  
  sub _undef {
    return undef;
    # Seems a little retarded but &CORE::undef fails in interconnect.
    # This is used for the default escape sequence function.
    # w/out the leading & it won't compile.
  }
  
  # clean up child processes
  sub DESTROY {
    my $status = $?; # save this as it gets mangled by the terminating spawned children
    my $self = shift;
    if (${*$self}{exp_Do_Soft_Close}) {
      $self->soft_close();
    }
    $self->hard_close();
    $? = $status; # restore it. otherwise deleting an Expect object may mangle $?, which is unintuitive
  }
  
  1;
EXPECT

$fatpacked{"IO/Pty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_PTY';
  # Documentation at the __END__
  
  package IO::Pty;
  
  use strict;
  use Carp;
  use IO::Tty qw(TIOCSCTTY TCSETCTTY TIOCNOTTY);
  use IO::File;
  require POSIX;
  
  use vars qw(@ISA $VERSION);
  
  $VERSION = '1.10'; # keep same as in Tty.pm
  
  @ISA = qw(IO::Handle);
  eval { local $^W = 0; undef local $SIG{__DIE__}; require IO::Stty };
  push @ISA, "IO::Stty" if (not $@);  # if IO::Stty is installed
  
  sub new {
    my ($class) = $_[0] || "IO::Pty";
    $class = ref($class) if ref($class);
    @_ <= 1 or croak 'usage: new $class';
  
    my ($ptyfd, $ttyfd, $ttyname) = pty_allocate();
  
    croak "Cannot open a pty" if not defined $ptyfd;
  
    my $pty = $class->SUPER::new_from_fd($ptyfd, "r+");
    croak "Cannot create a new $class from fd $ptyfd: $!" if not $pty;
    $pty->autoflush(1);
    bless $pty => $class;
  
    my $slave = IO::Tty->new_from_fd($ttyfd, "r+");
    croak "Cannot create a new IO::Tty from fd $ttyfd: $!" if not $slave;
    $slave->autoflush(1);
  
    ${*$pty}{'io_pty_slave'} = $slave;
    ${*$pty}{'io_pty_ttyname'} = $ttyname;
    ${*$slave}{'io_tty_ttyname'} = $ttyname;
  
    return $pty;
  }
  
  sub ttyname {
    @_ == 1 or croak 'usage: $pty->ttyname();';
    my $pty = shift;
    ${*$pty}{'io_pty_ttyname'};
  }
  
  
  sub close_slave {
    @_ == 1 or croak 'usage: $pty->close_slave();';
  
    my $master = shift;
  
    if (exists ${*$master}{'io_pty_slave'}) {
      close ${*$master}{'io_pty_slave'};
      delete ${*$master}{'io_pty_slave'};
    }
  }
  
  sub slave {
    @_ == 1 or croak 'usage: $pty->slave();';
  
    my $master = shift;
  
    if (exists ${*$master}{'io_pty_slave'}) {
      return ${*$master}{'io_pty_slave'};
    }
  
    my $tty = ${*$master}{'io_pty_ttyname'};
  
    my $slave = new IO::Tty;
  
    $slave->open($tty, O_RDWR | O_NOCTTY) ||
      croak "Cannot open slave $tty: $!";
  
    return $slave;
  }
  
  sub make_slave_controlling_terminal {
    @_ == 1 or croak 'usage: $pty->make_slave_controlling_terminal();';
  
    my $self = shift;
    local(*DEVTTY);
  
    # loose controlling terminal explicitely
    if (defined TIOCNOTTY) {
      if (open (\*DEVTTY, "/dev/tty")) {
        ioctl( \*DEVTTY, TIOCNOTTY, 0 );
        close \*DEVTTY;
      }
    }
  
    # Create a new 'session', lose controlling terminal.
    if (not POSIX::setsid()) {
      warn "setsid() failed, strange behavior may result: $!\r\n" if $^W;
    }
  
    if (open(\*DEVTTY, "/dev/tty")) {
      warn "Could not disconnect from controlling terminal?!\n" if $^W;
      close \*DEVTTY;
    }
  
    # now open slave, this should set it as controlling tty on some systems
    my $ttyname = ${*$self}{'io_pty_ttyname'};
    my $slv = new IO::Tty;
    $slv->open($ttyname, O_RDWR)
      or croak "Cannot open slave $ttyname: $!";
  
    if (not exists ${*$self}{'io_pty_slave'}) {
      ${*$self}{'io_pty_slave'} = $slv;
    } else {
      $slv->close;
    }
  
    # Acquire a controlling terminal if this doesn't happen automatically
    if (not open(\*DEVTTY, "/dev/tty")) {
      if (defined TIOCSCTTY) {
        if (not defined ioctl( ${*$self}{'io_pty_slave'}, TIOCSCTTY, 0 )) {
          warn "warning: TIOCSCTTY failed, slave might not be set as controlling terminal: $!" if $^W;
        }
      } elsif (defined TCSETCTTY) {
        if (not defined ioctl( ${*$self}{'io_pty_slave'}, TCSETCTTY, 0 )) {
          warn "warning: TCSETCTTY failed, slave might not be set as controlling terminal: $!" if $^W;
        }
      } else {
        warn "warning: You have neither TIOCSCTTY nor TCSETCTTY on your system\n" if $^W;
        return 0;
      }
    }
  
    if (not open(\*DEVTTY, "/dev/tty")) {
      warn "Error: could not connect pty as controlling terminal!\n";
      return undef;
    } else {
      close \*DEVTTY;
    }
    
    return 1;
  }
  
  *clone_winsize_from = \&IO::Tty::clone_winsize_from;
  *set_raw = \&IO::Tty::set_raw;
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Pty - Pseudo TTY object class
  
  =head1 VERSION
  
  1.10
  
  =head1 SYNOPSIS
  
      use IO::Pty;
  
      $pty = new IO::Pty;
  
      $slave  = $pty->slave;
  
      foreach $val (1..10) {
  	print $pty "$val\n";
  	$_ = <$slave>;
  	print "$_";
      }
  
      close($slave);
  
  
  =head1 DESCRIPTION
  
  C<IO::Pty> provides an interface to allow the creation of a pseudo tty.
  
  C<IO::Pty> inherits from C<IO::Handle> and so provide all the methods
  defined by the C<IO::Handle> package.
  
  Please note that pty creation is very system-dependend.  If you have
  problems, see L<IO::Tty> for help.
  
  
  =head1 CONSTRUCTOR
  
  =over 3
  
  =item new
  
  The C<new> constructor takes no arguments and returns a new file
  object which is the master side of the pseudo tty.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item ttyname()
  
  Returns the name of the slave pseudo tty. On UNIX machines this will
  be the pathname of the device.  Use this name for informational
  purpose only, to get a slave filehandle, use slave().
  
  =item slave()
  
  The C<slave> method will return the slave filehandle of the given
  master pty, opening it anew if necessary.  If IO::Stty is installed,
  you can then call C<$slave-E<gt>stty()> to modify the terminal settings.
  
  =item close_slave()
  
  The slave filehandle will be closed and destroyed.  This is necessary
  in the parent after forking to get rid of the open filehandle,
  otherwise the parent will not notice if the child exits.  Subsequent
  calls of C<slave()> will return a newly opened slave filehandle.
  
  =item make_slave_controlling_terminal()
  
  This will set the slave filehandle as the controlling terminal of the
  current process, which will become a session leader, so this should
  only be called by a child process after a fork(), e.g. in the callback
  to C<sync_exec()> (see L<Proc::SyncExec>).  See the C<try> script
  (also C<test.pl>) for an example how to correctly spawn a subprocess.
  
  =item set_raw()
  
  Will set the pty to raw.  Note that this is a one-way operation, you
  need IO::Stty to set the terminal settings to anything else.
  
  On some systems, the master pty is not a tty.  This method checks for
  that and returns success anyway on such systems.  Note that this
  method must be called on the slave, and probably should be called on
  the master, just to be sure, i.e.
  
    $pty->slave->set_raw();
    $pty->set_raw();
  
  
  =item clone_winsize_from(\*FH)
  
  Gets the terminal size from filehandle FH (which must be a terminal)
  and transfers it to the pty.  Returns true on success and undef on
  failure.  Note that this must be called upon the I<slave>, i.e.
  
   $pty->slave->clone_winsize_from(\*STDIN);
  
  On some systems, the master pty also isatty.  I actually have no
  idea if setting terminal sizes there is passed through to the slave,
  so if this method is called for a master that is not a tty, it
  silently returns OK.
  
  See the C<try> script for example code how to propagate SIGWINCH.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<IO::Tty>, L<IO::Tty::Constant>, L<IO::Handle>, L<Expect>, L<Proc::SyncExec>
  
  
  =head1 MAILING LISTS
  
  As this module is mainly used by Expect, support for it is available
  via the two Expect mailing lists, expectperl-announce and
  expectperl-discuss, at
  
    http://lists.sourceforge.net/lists/listinfo/expectperl-announce
  
  and
  
    http://lists.sourceforge.net/lists/listinfo/expectperl-discuss
  
  
  =head1 AUTHORS
  
  Originally by Graham Barr E<lt>F<gbarr@pobox.com>E<gt>, based on the
  Ptty module by Nick Ing-Simmons E<lt>F<nik@tiuk.ti.com>E<gt>.
  
  Now maintained and heavily rewritten by Roland Giersig
  E<lt>F<RGiersig@cpan.org>E<gt>.
  
  Contains copyrighted stuff from openssh v3.0p1, authored by 
  Tatu Ylonen <ylo@cs.hut.fi>, Markus Friedl and Todd C. Miller
  <Todd.Miller@courtesan.com>.
  
  
  =head1 COPYRIGHT
  
  Now all code is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Nevertheless the above AUTHORS retain their copyrights to the various
  parts and want to receive credit if their source code is used.
  See the source for details.
  
  
  =head1 DISCLAIMER
  
  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
  DAMAGE.
  
  In other words: Use at your own risk.  Provided as is.  Your mileage
  may vary.  Read the source, Luke!
  
  And finally, just to be sure:
  
  Any Use of This Product, in Any Manner Whatsoever, Will Increase the
  Amount of Disorder in the Universe. Although No Liability Is Implied
  Herein, the Consumer Is Warned That This Process Will Ultimately Lead
  to the Heat Death of the Universe.
  
  =cut
  
IO_PTY

$fatpacked{"IO/Tty/Constant.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_TTY_CONSTANT';
  
  package IO::Tty::Constant;
  
  use vars qw(@ISA @EXPORT_OK);
  require Exporter;
  
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(B0 B110 B115200 B1200 B134 B150 B153600 B1800 B19200 B200 B230400 B2400 B300 B307200 B38400 B460800 B4800 B50 B57600 B600 B75 B76800 B9600 BRKINT BS0 BS1 BSDLY CBAUD CBAUDEXT CBRK CCTS_OFLOW CDEL CDSUSP CEOF CEOL CEOL2 CEOT CERASE CESC CFLUSH CIBAUD CIBAUDEXT CINTR CKILL CLNEXT CLOCAL CNSWTCH CNUL CQUIT CR0 CR1 CR2 CR3 CRDLY CREAD CRPRNT CRTSCTS CRTSXOFF CRTS_IFLOW CS5 CS6 CS7 CS8 CSIZE CSTART CSTOP CSTOPB CSUSP CSWTCH CWERASE DEFECHO DIOC DIOCGETP DIOCSETP DOSMODE ECHO ECHOCTL ECHOE ECHOK ECHOKE ECHONL ECHOPRT EXTA EXTB FF0 FF1 FFDLY FIORDCHK FLUSHO HUPCL ICANON ICRNL IEXTEN IGNBRK IGNCR IGNPAR IMAXBEL INLCR INPCK ISIG ISTRIP IUCLC IXANY IXOFF IXON KBENABLED LDCHG LDCLOSE LDDMAP LDEMAP LDGETT LDGMAP LDIOC LDNMAP LDOPEN LDSETT LDSMAP LOBLK NCCS NL0 NL1 NLDLY NOFLSH OCRNL OFDEL OFILL OLCUC ONLCR ONLRET ONOCR OPOST PAGEOUT PARENB PAREXT PARMRK PARODD PENDIN RCV1EN RTS_TOG TAB0 TAB1 TAB2 TAB3 TABDLY TCDSET TCFLSH TCGETA TCGETS TCIFLUSH TCIOFF TCIOFLUSH TCION TCOFLUSH TCOOFF TCOON TCSADRAIN TCSAFLUSH TCSANOW TCSBRK TCSETA TCSETAF TCSETAW TCSETCTTY TCSETS TCSETSF TCSETSW TCXONC TERM_D40 TERM_D42 TERM_H45 TERM_NONE TERM_TEC TERM_TEX TERM_V10 TERM_V61 TIOCCBRK TIOCCDTR TIOCCONS TIOCEXCL TIOCFLUSH TIOCGETD TIOCGETC TIOCGETP TIOCGLTC TIOCSETC TIOCSETN TIOCSETP TIOCSLTC TIOCGPGRP TIOCGSID TIOCGSOFTCAR TIOCGWINSZ TIOCHPCL TIOCKBOF TIOCKBON TIOCLBIC TIOCLBIS TIOCLGET TIOCLSET TIOCMBIC TIOCMBIS TIOCMGET TIOCMSET TIOCM_CAR TIOCM_CD TIOCM_CTS TIOCM_DSR TIOCM_DTR TIOCM_LE TIOCM_RI TIOCM_RNG TIOCM_RTS TIOCM_SR TIOCM_ST TIOCNOTTY TIOCNXCL TIOCOUTQ TIOCREMOTE TIOCSBRK TIOCSCTTY TIOCSDTR TIOCSETD TIOCSIGNAL TIOCSPGRP TIOCSSID TIOCSSOFTCAR TIOCSTART TIOCSTI TIOCSTOP TIOCSWINSZ TM_ANL TM_CECHO TM_CINVIS TM_LCF TM_NONE TM_SET TM_SNL TOSTOP VCEOF VCEOL VDISCARD VDSUSP VEOF VEOL VEOL2 VERASE VINTR VKILL VLNEXT VMIN VQUIT VREPRINT VSTART VSTOP VSUSP VSWTCH VT0 VT1 VTDLY VTIME VWERASE WRAP XCASE XCLUDE XMT1EN XTABS);
  
  __END__
  
  =head1 NAME
  
  IO::Tty::Constant - Terminal Constants (autogenerated)
  
  =head1 SYNOPSIS
  
   use IO::Tty::Constant qw(TIOCNOTTY);
   ...
  
  =head1 DESCRIPTION
  
  This package defines constants usually found in <termio.h> or
  <termios.h> (and their #include hierarchy).  Find below an
  autogenerated alphabetic list of all known constants and whether they
  are defined on your system (prefixed with '+') and have compilation
  problems ('o').  Undefined or problematic constants are set to 'undef'.
  
  =head1 DEFINED CONSTANTS
  
  =item +
  
  B0
  
  =item +
  
  B110
  
  =item +
  
  B115200
  
  =item +
  
  B1200
  
  =item +
  
  B134
  
  =item +
  
  B150
  
  =item -
  
  B153600
  
  =item +
  
  B1800
  
  =item +
  
  B19200
  
  =item +
  
  B200
  
  =item +
  
  B230400
  
  =item +
  
  B2400
  
  =item +
  
  B300
  
  =item -
  
  B307200
  
  =item +
  
  B38400
  
  =item +
  
  B460800
  
  =item +
  
  B4800
  
  =item +
  
  B50
  
  =item +
  
  B57600
  
  =item +
  
  B600
  
  =item +
  
  B75
  
  =item -
  
  B76800
  
  =item +
  
  B9600
  
  =item +
  
  BRKINT
  
  =item +
  
  BS0
  
  =item +
  
  BS1
  
  =item +
  
  BSDLY
  
  =item +
  
  CBAUD
  
  =item -
  
  CBAUDEXT
  
  =item +
  
  CBRK
  
  =item -
  
  CCTS_OFLOW
  
  =item -
  
  CDEL
  
  =item +
  
  CDSUSP
  
  =item +
  
  CEOF
  
  =item +
  
  CEOL
  
  =item -
  
  CEOL2
  
  =item +
  
  CEOT
  
  =item +
  
  CERASE
  
  =item -
  
  CESC
  
  =item +
  
  CFLUSH
  
  =item +
  
  CIBAUD
  
  =item -
  
  CIBAUDEXT
  
  =item +
  
  CINTR
  
  =item +
  
  CKILL
  
  =item +
  
  CLNEXT
  
  =item +
  
  CLOCAL
  
  =item -
  
  CNSWTCH
  
  =item -
  
  CNUL
  
  =item +
  
  CQUIT
  
  =item +
  
  CR0
  
  =item +
  
  CR1
  
  =item +
  
  CR2
  
  =item +
  
  CR3
  
  =item +
  
  CRDLY
  
  =item +
  
  CREAD
  
  =item +
  
  CRPRNT
  
  =item +
  
  CRTSCTS
  
  =item -
  
  CRTSXOFF
  
  =item -
  
  CRTS_IFLOW
  
  =item +
  
  CS5
  
  =item +
  
  CS6
  
  =item +
  
  CS7
  
  =item +
  
  CS8
  
  =item +
  
  CSIZE
  
  =item +
  
  CSTART
  
  =item +
  
  CSTOP
  
  =item +
  
  CSTOPB
  
  =item +
  
  CSUSP
  
  =item -
  
  CSWTCH
  
  =item +
  
  CWERASE
  
  =item -
  
  DEFECHO
  
  =item -
  
  DIOC
  
  =item -
  
  DIOCGETP
  
  =item -
  
  DIOCSETP
  
  =item -
  
  DOSMODE
  
  =item +
  
  ECHO
  
  =item +
  
  ECHOCTL
  
  =item +
  
  ECHOE
  
  =item +
  
  ECHOK
  
  =item +
  
  ECHOKE
  
  =item +
  
  ECHONL
  
  =item +
  
  ECHOPRT
  
  =item +
  
  EXTA
  
  =item +
  
  EXTB
  
  =item +
  
  FF0
  
  =item +
  
  FF1
  
  =item +
  
  FFDLY
  
  =item -
  
  FIORDCHK
  
  =item +
  
  FLUSHO
  
  =item +
  
  HUPCL
  
  =item +
  
  ICANON
  
  =item +
  
  ICRNL
  
  =item +
  
  IEXTEN
  
  =item +
  
  IGNBRK
  
  =item +
  
  IGNCR
  
  =item +
  
  IGNPAR
  
  =item +
  
  IMAXBEL
  
  =item +
  
  INLCR
  
  =item +
  
  INPCK
  
  =item +
  
  ISIG
  
  =item +
  
  ISTRIP
  
  =item +
  
  IUCLC
  
  =item +
  
  IXANY
  
  =item +
  
  IXOFF
  
  =item +
  
  IXON
  
  =item -
  
  KBENABLED
  
  =item -
  
  LDCHG
  
  =item -
  
  LDCLOSE
  
  =item -
  
  LDDMAP
  
  =item -
  
  LDEMAP
  
  =item -
  
  LDGETT
  
  =item -
  
  LDGMAP
  
  =item -
  
  LDIOC
  
  =item -
  
  LDNMAP
  
  =item -
  
  LDOPEN
  
  =item -
  
  LDSETT
  
  =item -
  
  LDSMAP
  
  =item -
  
  LOBLK
  
  =item +
  
  NCCS
  
  =item +
  
  NL0
  
  =item +
  
  NL1
  
  =item +
  
  NLDLY
  
  =item +
  
  NOFLSH
  
  =item +
  
  OCRNL
  
  =item +
  
  OFDEL
  
  =item +
  
  OFILL
  
  =item +
  
  OLCUC
  
  =item +
  
  ONLCR
  
  =item +
  
  ONLRET
  
  =item +
  
  ONOCR
  
  =item +
  
  OPOST
  
  =item -
  
  PAGEOUT
  
  =item +
  
  PARENB
  
  =item -
  
  PAREXT
  
  =item +
  
  PARMRK
  
  =item +
  
  PARODD
  
  =item +
  
  PENDIN
  
  =item -
  
  RCV1EN
  
  =item -
  
  RTS_TOG
  
  =item +
  
  TAB0
  
  =item +
  
  TAB1
  
  =item +
  
  TAB2
  
  =item +
  
  TAB3
  
  =item +
  
  TABDLY
  
  =item -
  
  TCDSET
  
  =item +
  
  TCFLSH
  
  =item +
  
  TCGETA
  
  =item +
  
  TCGETS
  
  =item +
  
  TCIFLUSH
  
  =item +
  
  TCIOFF
  
  =item +
  
  TCIOFLUSH
  
  =item +
  
  TCION
  
  =item +
  
  TCOFLUSH
  
  =item +
  
  TCOOFF
  
  =item +
  
  TCOON
  
  =item +
  
  TCSADRAIN
  
  =item +
  
  TCSAFLUSH
  
  =item +
  
  TCSANOW
  
  =item +
  
  TCSBRK
  
  =item +
  
  TCSETA
  
  =item +
  
  TCSETAF
  
  =item +
  
  TCSETAW
  
  =item -
  
  TCSETCTTY
  
  =item +
  
  TCSETS
  
  =item +
  
  TCSETSF
  
  =item +
  
  TCSETSW
  
  =item +
  
  TCXONC
  
  =item -
  
  TERM_D40
  
  =item -
  
  TERM_D42
  
  =item -
  
  TERM_H45
  
  =item -
  
  TERM_NONE
  
  =item -
  
  TERM_TEC
  
  =item -
  
  TERM_TEX
  
  =item -
  
  TERM_V10
  
  =item -
  
  TERM_V61
  
  =item +
  
  TIOCCBRK
  
  =item -
  
  TIOCCDTR
  
  =item +
  
  TIOCCONS
  
  =item +
  
  TIOCEXCL
  
  =item -
  
  TIOCFLUSH
  
  =item +
  
  TIOCGETD
  
  =item -
  
  TIOCGETC
  
  =item -
  
  TIOCGETP
  
  =item -
  
  TIOCGLTC
  
  =item -
  
  TIOCSETC
  
  =item -
  
  TIOCSETN
  
  =item -
  
  TIOCSETP
  
  =item -
  
  TIOCSLTC
  
  =item +
  
  TIOCGPGRP
  
  =item +
  
  TIOCGSID
  
  =item +
  
  TIOCGSOFTCAR
  
  =item +
  
  TIOCGWINSZ
  
  =item -
  
  TIOCHPCL
  
  =item -
  
  TIOCKBOF
  
  =item -
  
  TIOCKBON
  
  =item -
  
  TIOCLBIC
  
  =item -
  
  TIOCLBIS
  
  =item -
  
  TIOCLGET
  
  =item -
  
  TIOCLSET
  
  =item +
  
  TIOCMBIC
  
  =item +
  
  TIOCMBIS
  
  =item +
  
  TIOCMGET
  
  =item +
  
  TIOCMSET
  
  =item +
  
  TIOCM_CAR
  
  =item +
  
  TIOCM_CD
  
  =item +
  
  TIOCM_CTS
  
  =item +
  
  TIOCM_DSR
  
  =item +
  
  TIOCM_DTR
  
  =item +
  
  TIOCM_LE
  
  =item +
  
  TIOCM_RI
  
  =item +
  
  TIOCM_RNG
  
  =item +
  
  TIOCM_RTS
  
  =item +
  
  TIOCM_SR
  
  =item +
  
  TIOCM_ST
  
  =item +
  
  TIOCNOTTY
  
  =item +
  
  TIOCNXCL
  
  =item +
  
  TIOCOUTQ
  
  =item -
  
  TIOCREMOTE
  
  =item +
  
  TIOCSBRK
  
  =item +
  
  TIOCSCTTY
  
  =item -
  
  TIOCSDTR
  
  =item +
  
  TIOCSETD
  
  =item -
  
  TIOCSIGNAL
  
  =item +
  
  TIOCSPGRP
  
  =item -
  
  TIOCSSID
  
  =item +
  
  TIOCSSOFTCAR
  
  =item -
  
  TIOCSTART
  
  =item +
  
  TIOCSTI
  
  =item -
  
  TIOCSTOP
  
  =item +
  
  TIOCSWINSZ
  
  =item -
  
  TM_ANL
  
  =item -
  
  TM_CECHO
  
  =item -
  
  TM_CINVIS
  
  =item -
  
  TM_LCF
  
  =item -
  
  TM_NONE
  
  =item -
  
  TM_SET
  
  =item -
  
  TM_SNL
  
  =item +
  
  TOSTOP
  
  =item -
  
  VCEOF
  
  =item -
  
  VCEOL
  
  =item +
  
  VDISCARD
  
  =item -
  
  VDSUSP
  
  =item +
  
  VEOF
  
  =item +
  
  VEOL
  
  =item +
  
  VEOL2
  
  =item +
  
  VERASE
  
  =item +
  
  VINTR
  
  =item +
  
  VKILL
  
  =item +
  
  VLNEXT
  
  =item +
  
  VMIN
  
  =item +
  
  VQUIT
  
  =item +
  
  VREPRINT
  
  =item +
  
  VSTART
  
  =item +
  
  VSTOP
  
  =item +
  
  VSUSP
  
  =item -
  
  VSWTCH
  
  =item +
  
  VT0
  
  =item +
  
  VT1
  
  =item +
  
  VTDLY
  
  =item +
  
  VTIME
  
  =item +
  
  VWERASE
  
  =item -
  
  WRAP
  
  =item +
  
  XCASE
  
  =item -
  
  XCLUDE
  
  =item -
  
  XMT1EN
  
  =item +
  
  XTABS
  
  
  =head1 FOR MORE INFO SEE
  
  L<IO::Tty>
  
  =cut
  
IO_TTY_CONSTANT

$fatpacked{"RPM/Specfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'RPM_SPECFILE';
  package RPM::Specfile;
  
  use POSIX;
  
  use strict;
  
  use vars qw/$VERSION/;
  
  $VERSION = '1.51';
  
  sub new {
    my $class = shift;
  
    my $self = bless { }, $class;
  
    return $self;
  }
  
  my @simple_accessors =
    qw(
       build buildarch buildrequires buildroot check clean description distribution
       epoch file_param group install license macros name packager post postun
       pre preun prep release requires summary url vendor version
      );
  
  foreach my $field (@simple_accessors) {
    my $sub = q {
      sub RPM::Specfile::[[field]] {
        my $self = shift;
        if (@_) {
          my $value = shift;
          $self->{__[[field]]__} = $value;
        }
        return $self->{__[[field]]__};
      }
    };
  
    $sub =~ s/\[\[field\]\]/$field/g;
    eval $sub;
  
    if ($@) {
      die $@;
    }
  }
  
  my @array_accessors = qw/source patch changelog provide require file buildrequire prefix/;
  
  foreach my $field (@array_accessors) {
    my $sub = q {
      sub RPM::Specfile::[[field]] {
        my $self = shift;
        $self->{__[[field]]__} ||= [ ];
  
        if (@_) {
          my $index = shift;
          if (@_) {
            my $value = shift;
            $self->{__[[field]]__}->[$index] = $value;
          }
          return $self->{__[[field]]__}->[$index];
        }
        else {
          return @{$self->{__[[field]]__}};
        }
      }
  
      sub RPM::Specfile::push_[[field]] {
        my $self = shift;
        my $entry = shift;
  
        $self->{__[[field]]__} ||= [ ];
        push @{$self->{__[[field]]__}}, $entry;
      }
  
      sub RPM::Specfile::clear_[[field]] {
        my $self = shift;
        my $entry = shift;
  
        $self->{__[[field]]__} = [ ];
      }
  
    };
  
    $sub =~ s/\[\[field\]\]/$field/g;
    eval $sub;
  
    if ($@) {
      die $@;
    }
  }
  
  
  sub add_changelog_entry {
    my $self = shift;
    my $who = shift;
    my $entry = shift;
    my $version = shift;
  
    POSIX::setlocale( &POSIX::LC_ALL, "C" );
  
    my $output;
    $output .= strftime("* %a %b %d %Y $who", localtime time);
    $output .= " - $version" if $version;
    $output .= "\n- $entry\n";
  
    $self->push_changelog($output);
  }
  
  sub generate_specfile {
    my $self = shift;
  
    my $output;
  
    my %defaults =
      ( buildroot => "%{_tmppath}/%{name}-%{version}-%{release}-root" );
    $self->$_($self->$_() || $defaults{$_}) foreach keys %defaults;
  
    my %proper_names = ( url           => 'URL',
                         buildroot     => 'BuildRoot',
                         buildrequires => 'BuildRequires',
                         buildarch     => 'BuildArch',
                       );
  
    #
    # Add any macro definitions to the begining.
    $output .= $self->macros() . "\n" if defined $self->macros();
  
    foreach my $tag (qw/summary name version release epoch packager vendor distribution license group url buildroot buildarch/) {
      my $proper = $proper_names{$tag} || ucfirst $tag;
  
      next unless defined $self->$tag();
      $output .= "$proper: " . $self->$tag() . "\n";
    }
  
    my $req_format = sub {
      my $req = shift;
      my $ver = shift;
  
      if (ref $req) {
        ($req, $ver) = @$req;
      }
  
      if (defined $ver and $ver != 0) {
        return "$req >= $ver";
      }
      else {
        return "$req";
      }
    };
  
    foreach my $tag (qw/requires buildrequires/) {
      my $proper = $proper_names{$tag} || ucfirst $tag;
  
      next unless defined $self->$tag();
  
      $output .= "$proper: " . $req_format->($self->$tag) . "\n";
    }
  
    my @reqs = $self->buildrequire;
    for my $i (0 .. $#reqs) {
      $output .= "BuildRequires: " . $req_format->($reqs[$i]) . "\n";
    }
  
    @reqs = $self->require;
    for my $i (0 .. $#reqs) {
      $output .= "Requires: " . $req_format->($reqs[$i]) .  "\n";
    }
  
    my @sources = $self->source;
    for my $i (0 .. $#sources) {
      $output .= "Source$i: $sources[$i]\n";
    }
  
    my @patches = $self->patch;
    for my $i (0 .. $#patches) {
      $output .= "Patch$i: $patches[$i]\n";
    }
  
    #
    # Add any prefixes:
    my @prefixes = $self->prefix;
    for my $i (0 .. $#prefixes) {
      $output .= "Prefix: $prefixes[$i]\n";
    }
    $output .= "\n";
  
    #
    # Add patch entries to the %prep section if they exist:
    my $prep = $self->prep();
    for my $i (0 .. $#patches) {
      $prep .= "\n" if($i == 0);		# Just in case they did not add a newline
      $prep .= "%patch${i} -p1\n";
    }
    $self->prep($prep) if(defined($prep));
  
    if ($self->check) {
      my $build = $self->build;
  
      my ($cond, $body) = (undef, $self->check);
      if (ref $body) {
        $cond = $body->[0];
        $body = $body->[1];
      }
  
      $build .= "\n%check";
      if ($cond) {
        $build .= " $cond";
      }
      $build .= "\n$body\n";
  
      $self->build($build);
    }
  
    foreach my $sect (qw/description prep build install clean pre post preun postun/) {
      next if(!defined($self->$sect()));
      $output .= "%$sect\n";
      my $content = $self->$sect();
      # remove leading and trailing whitespace and spurious linefeeds
      $content =~ s/^\s*\n*//s;
      $content =~ s/[\s\n]*$/\n\n/s;
      $output .= $content;
    }
  
    if ($self->file_param) {
      $output .= "%files " . $self->file_param . "\n";
    }
    else {
      $output .= "%files\n";
    }
    $output .= "$_\n" foreach $self->file;
  
    $output .= "\n%changelog\n";
    $output .= "$_\n" foreach $self->changelog;
  
    return $output;
  }
  
  sub write_specfile {
    my $self = shift;
    my $dest = shift;
  
    open FH, ">$dest"
      or die "Can't open $dest: $!";
  
    print FH $self->generate_specfile;
  
    close FH;
  }
  
  1;
  
  __END__
  # Below is stub documentation for your module. You better edit it!
  # TODO: yes, I better edit this better.
  
  =head1 NAME
  
  RPM::Specfile - Perl extension for creating RPM Specfiles
  
  =head1 SYNOPSIS
  
    use RPM::Specfile;
  
  =head1 DESCRIPTION
  
  This is a simple module for creation of RPM Spec files.  Most of the methods in this
  module are the same name as the RPM Spec file element they represent but in lower
  case.  Furthermore the the methods are divided into two groups:
  
  =over 4
  
  =item Simple Accessors
  
  These methods have the have the exact name as the element they represent (in lower
  case).  If passed no arguments return a scalar representing the element.  If
  an argument is passed they will set the value of the element.
  
  =item List Accessors
  
  These methods manipulate items in the spec file that are lists (e.g. the list of
  patches maintained by the spec file).  Each element that is represented by a list
  accessor will have at least three methods associated with it.
  
  =over 8
  
  =item *
  
  A method to directly manipulate individual members of the list.  These methods
  take as a first argument the index into the list, and as a second argument
  the element value.  If no arguments are given it simply returns the list.
  If only the index is given it returns the list member at that index.  If
  the value is also given it will set the list member associated with the index.
  
  =item *
  
  A method to push a member onto the list.  Each of these methods have C<push_>
  at the begining of their name.
  
  =item *
  
  A method to clear the list.  Each of these methods have C<clear_>
  at the begining of their name.
  
  =back
  
  =back
  
  =head1 RPM SPEC FILE ORGANIZATION
  
  This section describes the basic structure of an RPM Spec file and how that
  applies to RPM::Specfile.  It does not attempt to give a full description of
  RPM Spec file syntax.
  
  RPM Spec files are divided into the following sections:
  
  =over 4
  
  =item Preamble
  
  This is where the meta information for the rpm is stored, such as its name version and
  description.  Also, macro definitions are generally put at the top of the preamble.
  The methods that are used to create this section are listed below:
  
  	buildarch(), buildrequire(), buildrequires(), buildroot(),
  	clear_buildrequire(), clear_changelog(), clear_patch(), clear_prefix(),
  	clear_provide(), clear_require(), clear_source(), description(), distribution(),
  	epoch(), group(), license(), macros(), name(), packager(), patch(), prefix(),
  	provide(), push_buildrequire(), push_patch(), push_prefix(), push_provide(),
  	push_require(), push_source(), release(), require(), requires(), source(),
  	summary(), url(), vendor(), version()
  	
  Many of the elements of the Preamble are required.  See Maximum RPM for documentation
  on which one are required and which ones are not.
  
  =item Build Scriptlets
  
  When rpms are built the install scriptlets are invoked.  These install
  scriptlets are %prep, %build, %install, and %clean.  The contents of these
  scripts can be set with the following methods:
  
  	build(), clean(), install(), prep()
  
  The %prep, %build, and %install scriptlets are required, but may be
  null.
  
  =item Install/Erase Scriplets
  
  When an RPM is installed or erased various scriplets may be invoked.
  These scriplets can be set via the following methods:
  
  	post(), postun(), pre(), preun()
  
  The install scriptlets are not required.
  
  =item Files
  
  The %files section is used to define what files should be delivered to the
  system.  It further defines what the permsisions and ownership of the files
  should be.  The methods that work with the %files sections are:
  
  	file(), push_file(), clear_file(), file_param()
  
  Note, a files section is required, but it may contain no entries.
  
  =item Change Log
  
  The last section in the spec file is the change log.  Methods to modify this are:
  
  	add_changelog_entry(), changelog(), push_changelog(), clear_changelog()
  
  =back
  
  =head2 EXPORT
  
  None by default.
  
  =head1 METHODS
  
  =item build
  
  Not sure what this one does.
  
  =item buildarch([$arch])
  
  Returns the build arch.  If $arch is given will set build arch to $arch.
  
  	$spec->buildarch('noarch');
  
  =item buildrequire([$index, $requirement])
  
  Returns a list of build requirement entries.  If $index and $requirement are provided,
  it will set the entry referenced by $index to $requirement.
  
  	@buildRequires = $spec->buildrequire();
  
  =item buildrequires([$requirement])
  
  Returns the build requires.  If $requirement is given, will set build requires line
  to $requirement.
  
  	$spec->buildrequires('noarch');
  
  =item buildroot([$root])
  
  Returns the build root (this is where rpm will build the package).  If $root is
  given, will set the build root to $root.
  
  	$spec->buildroot('/tmp/%{name}-%{version}-%{release}');
  
  =item clean([$scriptlet])
  
  Returns the %clean scriptlet.  If $scriptlet is given, will make the contents
  of $scriptlet the %clean scriptlet.
  
  	$spec->clean('rm -rf $RPM_BUILD_ROOT');
  
  =item changelog([$index, $entry])
  
  Returns a list of changelog entries.  If $index and $entry are provided it will
  set the entry referenced by $index to $entry.
  
  	@entries = $spec->changelog();
  
  =item clear_buildrequire()
  
  Clears the build requirement list.
  
  	$spec->clear_buildrequire();
  
  =item clear_changelog()
  
  Clears the list of changelog entries.
  
  	$spec->clear_changelog();
  
  =item clear_file()
  
  Clears the file list.
  
  	$spec->clear_file();
  
  =item clear_patch()
  
  Clears the patch list.
  
  	$spec->clear_patch();
  
  =item clear_prefix()
  
  Clears the prefix list.
  
  	$spec->clear_prefix();
  
  =item clear_provide()
  
  Clears the list of provisions.
  
  	$spec->clear_provide();
  
  =item clear_require()
  
  Clears the requirements list.
  
  	$spec->clear_require();
  
  =item clear_source()
  
  Clears the list of sources.
  
  	$spec->clear_source();
  
  =item description([$desc])
  
  Returns the description of the rpm.  If $desc is given, sets the description of the rpm.
  
  	$spec->description('An automatically generated RPM');
  
  =item distribution([$distro])
  
  Returns the distribution of the rpm.  If $distro is given, sets the distribution
  of the rpm.
  
  	$spec->distribution('RedHat');
  
  =item epoch([$epoch])
  
  Returns the epoch of the rpm.  If $epoch is given sets the epoch of the rpm to $epoch.
  
  	$spec->epoch('0');
  
  =item file([$index, $file])
  
  Returns a list of %file entries.  If $index and $file are provided, it will
  set the entry referenced by $index to $file.
  
  	@files = $spec->file();
  
  =item file_param([$param])
  
  Returns the parameters to add to the %files macro invocation.  If $param is given,
  $param will be appended to the %files macro.
  
  	$spec->file_param('-f file_list');
  
  =item group([$group])
  
  Returns the group in which the rpm belongs.  If $group is given, group will be set
  to $group.
  
  	$spec->group("Development/Libraries");
  
  =item install([$scriptlet])
  
  Returns the %install scriptlet.  If $scriptlet is given, the %install scriptlet
  will be set to this.
  
  	$spec->group('mkdir -p $RPM_BUILD_ROOT/usr/local/mypkg');
  
  =item license([$license])
  
  Returns the type of license the rpm is will be released under.  If $license is
  given, license will be set to $license.
  
  
  =item macros([$macro_defs])
  
  Returns the macro definitions that are before the preamble of the specfile.
  If $macro_defs is given, the macro definitions will be set to it.
  
  	$spec->macros("%define x 1\n%define y 2");
  
  =item name([$name])
  
  Returns the name of the rpm.  If $name is given, the name is set to $name.
  
  	$spec->name('perl-RPM-Specfile');
  
  =item packager([$packager])
  
  Returns the email address of the packager.  If $packager is set, packager is set to
  $packager.
  
  	$spec->packager('someone@some.where');
  
  =item patch([$index, $patch])
  
  Returns a list of patches.  If $index and $patch are provided it will
  set the entry referenced by $index to $patch.
  
  	@patches = $spec->patch();
  
  =item post([$scriptlet])
  
  Returns the contents of the %post scriptlet.  If $scriptlet is given, %post is set
  to the value of $scriptlet.
  
  	$spec->post("echo Running %%post...\nexit 0");
  
  =item postun([$scriptlet])
  
  Returns the contents of the %postun scriptlet.  If $scriptlet is given, %postun is set
  to the value of $scriptlet.
  
  	$spec->postun("echo Running %%postun...\nexit 0");
  
  =item pre([$scriptlet])
  
  Returns the contents of the %pre scriptlet.  If $scriptlet is given, %pre is set
  to the value of $scriptlet.
  
  	$spec->pre("echo Running %%pre...\nexit 0");
  
  =item prefix([$index, $prefix])
  
  Returns a list of prefix/relocation entries.  If $index and $prefix are provided it will
  set the entry referenced by $index to $prefix.
  
  	@prefixes = $spec->prefix();
  
  =item preun([$scriptlet])
  
  Returns the contents of the %preun scriptlet.  If $scriptlet is given, %preun is set
  to the value of $scriptlet.
  
  	$spec->preun("echo Running %%preun...\nexit 0");
  
  =item prep([$scriptlet])
  
  Returns the contents of the %prep scriptlet.  If $scriptlet is given, %prep is set
  to the value of $scriptlet.
  
  	$spec->prep("echo Running %%prep...\nexit 0");
  
  =item provide([$index, $provision])
  
  Returns a list of provision entries.  If $index and $provision are provided it will
  set the entry referenced by $index to $provision.
  
  	@provides = $spec->provide();
  
  =item push_buildrequire([$entry])
  
  Push a build requirement onto the list of build requirments.
  
  	$spec->push_buildrequire('gcc >= 3.2');
  
  =item push_changelog([$entry])
  
  Pushes a changelog entry onto the list of changelog entries.
  
  =item push_file([$entry])
  
  Pushes a file onto the list of files.
  
  	$spec->push_file('%attr(0664, root, root) %dir /usr/local/mypkg');
  	$spec->push_file('%attr(0664, root, root) /usr/local/mypkg/myfile');
  
  =item push_patch([$entry])
  
  Pushes a patch onto the list of patches.
  
  	$spec->push_patch('autorollback.patch');
  
  Note, adding a patch implicitly adds entries to the %prep script.
  
  =item push_prefix([$prefix])
  
  Push a prefix onto to the list of valid relocations.
  
  	$spec->clear_prefix('/usr/local/mypkg');
  
  =item push_provide([$entry])
  
  Pushes a provision onto the list of provisions.
  
  	$spec->push_provide('kernel-tools = 2.6');
  
  =item push_require([$entry])
  
  Pushes a requirement onto the list of requirements.
  
  	$spec->push_require('perl(RPM::Specfile)');
  
  =item push_source([$entry])
  
  Pushes a source entry onto the list of sources.
  
  	$spec->push_source('wget-1.8.2.tar.gz');
  
  =item release([$release])
  
  Returns the release of the rpm.  If $release is specified, release is set to $release.
  
  	$spec->release('1.1');
  
  =item require([$index, $requirement])
  
  Returns a list of requirement entries.  If $index and $requirement are provided it will
  set the entry referenced by $index to $requirement.
  
  	@requires = $spec->require();
  
  =item requires([$requires])
  
  Returns the value of the Requires line.  If $requires is set, the Requires line will
  be set to $requires.
  
  	$spec->requires('xdelta > 0:1.1.3-11, vlock > 0:1.3-13');
  
  =item source([$index, $source])
  
  Returns a list of source entries.  If $index and $source are provided it will
  set the entry referenced by $index to $source.
  
  	@sources = $spec->source();
  
  =item summary([$summary])
  
  Returns the value of the Summary line.  If $summary is set, the Summary line will
  be set to $summary.
  
  =item url([$url])
  
  Returns the url of the rpm.  If $usr is set, the url is set to $url.
  
  	$spec->url('http://www.cpan.org');
  
  =item vendor([$vendor])
  
  Returns the vendor of the rpm.  If $vendor is set, the vendor is set to $vendor.
  
  	$spec->vendor('Perfect Distro, Inc.');
  
  =item version([$version])
  
  Returns the version of the rpm.  If $version is set, the version is set to $version.
  
  =item new
  
  Constructor of an RPM::Specfile object.
  
  	$spec = RPM::Specfile->new();
  
  =item add_changelog_entry($who, $entry, $version)
  
  Adds an entry to the change log.  $who should be set to something like:
  
  	your name<your_email@somewhere.com>
  
  $entry is the list of changes, and $version is the version to which the change
  log applies.
  
  	$spec->add_changelog('John Smith <jsmith@smiths.com>',
  		'- Added a great bit of functionality',
  		'1.0');
  
  This method will automatically generate the time of the entry.
  
  =item generate_specfile()
  
  Generates the specfile and returns it as a scalar.
  
  =item write_specfile($file)
  
  Writes specfile to $file.
  
  =head1 NOTE
  
  A good example of the use of RPM::Specfile is cpanflute2 which comes with the
  RPM::Specfile cpan archive.
  
  =head1 AUTHOR
  
  Chip Turner <cturner@pattern.net>
  
  =head1 LICENSE
  
  This module is distributed under the same terms as Perl itself:
  
  http://dev.perl.org/licenses/
  
  =head1 SEE ALSO
  
  L<perl>
  cpanflute2
  Maximum RPM (http://www.rpm.org/max-rpm/)
  
  =cut
RPM_SPECFILE

$fatpacked{"Text/Template.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_TEMPLATE';
  # -*- perl -*-
  # Text::Template.pm
  #
  # Fill in `templates'
  #
  # Copyright 1996, 1997, 1999, 2001, 2002, 2003, 2008 M-J. Dominus.
  # You may copy and distribute this program under the
  # same terms as Perl iteself.  
  # If in doubt, write to mjd-perl-template+@plover.com for a license.
  #
  # Version 1.45
  
  package Text::Template;
  require 5.004;
  use Exporter;
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(fill_in_file fill_in_string TTerror);
  use vars '$ERROR';
  use strict;
  
  $Text::Template::VERSION = '1.45';
  my %GLOBAL_PREPEND = ('Text::Template' => '');
  
  sub Version {
    $Text::Template::VERSION;
  }
  
  sub _param {
    my $kk;
    my ($k, %h) = @_;
    for $kk ($k, "\u$k", "\U$k", "-$k", "-\u$k", "-\U$k") {
      return $h{$kk} if exists $h{$kk};
    }
    return;
  }
  
  sub always_prepend
  {
    my $pack = shift;
    my $old = $GLOBAL_PREPEND{$pack};
    $GLOBAL_PREPEND{$pack} = shift;
    $old;
  }
  
  {
    my %LEGAL_TYPE;
    BEGIN { 
      %LEGAL_TYPE = map {$_=>1} qw(FILE FILEHANDLE STRING ARRAY);
    }
    sub new {
      my $pack = shift;
      my %a = @_;
      my $stype = uc(_param('type', %a)) || 'FILE';
      my $source = _param('source', %a);
      my $untaint = _param('untaint', %a);
      my $prepend = _param('prepend', %a);
      my $alt_delim = _param('delimiters', %a);
      my $broken = _param('broken', %a);
      unless (defined $source) {
        require Carp;
        Carp::croak("Usage: $ {pack}::new(TYPE => ..., SOURCE => ...)");
      }
      unless ($LEGAL_TYPE{$stype}) {
        require Carp;
        Carp::croak("Illegal value `$stype' for TYPE parameter");
      }
      my $self = {TYPE => $stype,
  		PREPEND => $prepend,
                  UNTAINT => $untaint,
                  BROKEN => $broken,
  		(defined $alt_delim ? (DELIM => $alt_delim) : ()),
  	       };
      # Under 5.005_03, if any of $stype, $prepend, $untaint, or $broken
      # are tainted, all the others become tainted too as a result of
      # sharing the expression with them.  We install $source separately
      # to prevent it from acquiring a spurious taint.
      $self->{SOURCE} = $source;
  
      bless $self => $pack;
      return unless $self->_acquire_data;
      
      $self;
    }
  }
  
  # Convert template objects of various types to type STRING,
  # in which the template data is embedded in the object itself.
  sub _acquire_data {
    my ($self) = @_;
    my $type = $self->{TYPE};
    if ($type eq 'STRING') {
      # nothing necessary    
    } elsif ($type eq 'FILE') {
      my $data = _load_text($self->{SOURCE});
      unless (defined $data) {
        # _load_text already set $ERROR
        return undef;
      }
      if ($self->{UNTAINT} && _is_clean($self->{SOURCE})) {
        _unconditionally_untaint($data);
      }
      $self->{TYPE} = 'STRING';
      $self->{FILENAME} = $self->{SOURCE};
      $self->{SOURCE} = $data;
    } elsif ($type eq 'ARRAY') {
      $self->{TYPE} = 'STRING';
      $self->{SOURCE} = join '', @{$self->{SOURCE}};
    } elsif ($type eq 'FILEHANDLE') {
      $self->{TYPE} = 'STRING';
      local $/;
      my $fh = $self->{SOURCE};
      my $data = <$fh>; # Extra assignment avoids bug in Solaris perl5.00[45].
      if ($self->{UNTAINT}) {
        _unconditionally_untaint($data);
      }
      $self->{SOURCE} = $data;
    } else {
      # This should have been caught long ago, so it represents a 
      # drastic `can't-happen' sort of failure
      my $pack = ref $self;
      die "Can only acquire data for $pack objects of subtype STRING, but this is $type; aborting";
    }
    $self->{DATA_ACQUIRED} = 1;
  }
  
  sub source {
    my ($self) = @_;
    $self->_acquire_data unless $self->{DATA_ACQUIRED};
    return $self->{SOURCE};
  }
  
  sub set_source_data {
    my ($self, $newdata) = @_;
    $self->{SOURCE} = $newdata;
    $self->{DATA_ACQUIRED} = 1;
    $self->{TYPE} = 'STRING';
    1;
  }
  
  sub compile {
    my $self = shift;
  
    return 1 if $self->{TYPE} eq 'PREPARSED';
  
    return undef unless $self->_acquire_data;
    unless ($self->{TYPE} eq 'STRING') {
      my $pack = ref $self;
      # This should have been caught long ago, so it represents a 
      # drastic `can't-happen' sort of failure
      die "Can only compile $pack objects of subtype STRING, but this is $self->{TYPE}; aborting";
    }
  
    my @tokens;
    my $delim_pats = shift() || $self->{DELIM};
  
    
  
    my ($t_open, $t_close) = ('{', '}');
    my $DELIM;			# Regex matches a delimiter if $delim_pats
    if (defined $delim_pats) {
      ($t_open, $t_close) = @$delim_pats;
      $DELIM = "(?:(?:\Q$t_open\E)|(?:\Q$t_close\E))";
      @tokens = split /($DELIM|\n)/, $self->{SOURCE};
    } else {
      @tokens = split /(\\\\(?=\\*[{}])|\\[{}]|[{}\n])/, $self->{SOURCE};
    }
    my $state = 'TEXT';
    my $depth = 0;
    my $lineno = 1;
    my @content;
    my $cur_item = '';
    my $prog_start;
    while (@tokens) {
      my $t = shift @tokens;
      next if $t eq '';
      if ($t eq $t_open) {	# Brace or other opening delimiter
        if ($depth == 0) {
  	push @content, [$state, $cur_item, $lineno] if $cur_item ne '';
  	$cur_item = '';
  	$state = 'PROG';
  	$prog_start = $lineno;
        } else {
  	$cur_item .= $t;
        }
        $depth++;
      } elsif ($t eq $t_close) {	# Brace or other closing delimiter
        $depth--;
        if ($depth < 0) {
  	$ERROR = "Unmatched close brace at line $lineno";
  	return undef;
        } elsif ($depth == 0) {
  	push @content, [$state, $cur_item, $prog_start] if $cur_item ne '';
  	$state = 'TEXT';
  	$cur_item = '';
        } else {
  	$cur_item .= $t;
        }
      } elsif (!$delim_pats && $t eq '\\\\') { # precedes \\\..\\\{ or \\\..\\\}
        $cur_item .= '\\';
      } elsif (!$delim_pats && $t =~ /^\\([{}])$/) { # Escaped (literal) brace?
  	$cur_item .= $1;
      } elsif ($t eq "\n") {	# Newline
        $lineno++;
        $cur_item .= $t;
      } else {			# Anything else
        $cur_item .= $t;
      }
    }
  
    if ($state eq 'PROG') {
      $ERROR = "End of data inside program text that began at line $prog_start";
      return undef;
    } elsif ($state eq 'TEXT') {
      push @content, [$state, $cur_item, $lineno] if $cur_item ne '';
    } else {
      die "Can't happen error #1";
    }
    
    $self->{TYPE} = 'PREPARSED';
    $self->{SOURCE} = \@content;
    1;
  }
  
  sub prepend_text {
    my ($self) = @_;
    my $t = $self->{PREPEND};
    unless (defined $t) {
      $t = $GLOBAL_PREPEND{ref $self};
      unless (defined $t) {
        $t = $GLOBAL_PREPEND{'Text::Template'};
      }
    }
    $self->{PREPEND} = $_[1] if $#_ >= 1;
    return $t;
  }
  
  sub fill_in {
    my $fi_self = shift;
    my %fi_a = @_;
  
    unless ($fi_self->{TYPE} eq 'PREPARSED') {
      my $delims = _param('delimiters', %fi_a);
      my @delim_arg = (defined $delims ? ($delims) : ());
      $fi_self->compile(@delim_arg)
        or return undef;
    }
  
    my $fi_varhash = _param('hash', %fi_a);
    my $fi_package = _param('package', %fi_a) ;
    my $fi_broken  = 
      _param('broken', %fi_a)  || $fi_self->{BROKEN} || \&_default_broken;
    my $fi_broken_arg = _param('broken_arg', %fi_a) || [];
    my $fi_safe = _param('safe', %fi_a);
    my $fi_ofh = _param('output', %fi_a);
    my $fi_eval_package;
    my $fi_scrub_package = 0;
    my $fi_filename = _param('filename') || $fi_self->{FILENAME} || 'template';
  
    my $fi_prepend = _param('prepend', %fi_a);
    unless (defined $fi_prepend) {
      $fi_prepend = $fi_self->prepend_text;
    }
  
    if (defined $fi_safe) {
      $fi_eval_package = 'main';
    } elsif (defined $fi_package) {
      $fi_eval_package = $fi_package;
    } elsif (defined $fi_varhash) {
      $fi_eval_package = _gensym();
      $fi_scrub_package = 1;
    } else {
      $fi_eval_package = caller;
    }
  
    my $fi_install_package;
    if (defined $fi_varhash) {
      if (defined $fi_package) {
        $fi_install_package = $fi_package;
      } elsif (defined $fi_safe) {
        $fi_install_package = $fi_safe->root;
      } else {
        $fi_install_package = $fi_eval_package; # The gensymmed one
      }
      _install_hash($fi_varhash => $fi_install_package);
    }
  
    if (defined $fi_package && defined $fi_safe) {
      no strict 'refs';
      # Big fat magic here: Fix it so that the user-specified package
      # is the default one available in the safe compartment.
      *{$fi_safe->root . '::'} = \%{$fi_package . '::'};   # LOD
    }
  
    my $fi_r = '';
    my $fi_item;
    foreach $fi_item (@{$fi_self->{SOURCE}}) {
      my ($fi_type, $fi_text, $fi_lineno) = @$fi_item;
      if ($fi_type eq 'TEXT') {
        if ($fi_ofh) {
  	print $fi_ofh $fi_text;
        } else {
  	$fi_r .= $fi_text;
        }
      } elsif ($fi_type eq 'PROG') {
        no strict;
        my $fi_lcomment = "#line $fi_lineno $fi_filename";
        my $fi_progtext = 
          "package $fi_eval_package; $fi_prepend;\n$fi_lcomment\n$fi_text;";
        my $fi_res;
        my $fi_eval_err = '';
        if ($fi_safe) {
          $fi_safe->reval(q{undef $OUT});
  	$fi_res = $fi_safe->reval($fi_progtext);
  	$fi_eval_err = $@;
  	my $OUT = $fi_safe->reval('$OUT');
  	$fi_res = $OUT if defined $OUT;
        } else {
  	my $OUT;
  	$fi_res = eval $fi_progtext;
  	$fi_eval_err = $@;
  	$fi_res = $OUT if defined $OUT;
        }
  
        # If the value of the filled-in text really was undef,
        # change it to an explicit empty string to avoid undefined
        # value warnings later.
        $fi_res = '' unless defined $fi_res;
  
        if ($fi_eval_err) {
  	$fi_res = $fi_broken->(text => $fi_text,
  			       error => $fi_eval_err,
  			       lineno => $fi_lineno,
  			       arg => $fi_broken_arg,
  			       );
  	if (defined $fi_res) {
  	  if (defined $fi_ofh) {
  	    print $fi_ofh $fi_res;
  	  } else {
  	    $fi_r .= $fi_res;
  	  }
  	} else {
  	  return $fi_res;		# Undefined means abort processing
  	}
        } else {
  	if (defined $fi_ofh) {
  	  print $fi_ofh $fi_res;
  	} else {
  	  $fi_r .= $fi_res;
  	}
        }
      } else {
        die "Can't happen error #2";
      }
    }
  
    _scrubpkg($fi_eval_package) if $fi_scrub_package;
    defined $fi_ofh ? 1 : $fi_r;
  }
  
  sub fill_this_in {
    my $pack = shift;
    my $text = shift;
    my $templ = $pack->new(TYPE => 'STRING', SOURCE => $text, @_)
      or return undef;
    $templ->compile or return undef;
    my $result = $templ->fill_in(@_);
    $result;
  }
  
  sub fill_in_string {
    my $string = shift;
    my $package = _param('package', @_);
    push @_, 'package' => scalar(caller) unless defined $package;
    Text::Template->fill_this_in($string, @_);
  }
  
  sub fill_in_file {
    my $fn = shift;
    my $templ = Text::Template->new(TYPE => 'FILE', SOURCE => $fn, @_)
      or return undef;
    $templ->compile or return undef;
    my $text = $templ->fill_in(@_);
    $text;
  }
  
  sub _default_broken {
    my %a = @_;
    my $prog_text = $a{text};
    my $err = $a{error};
    my $lineno = $a{lineno};
    chomp $err;
  #  $err =~ s/\s+at .*//s;
    "Program fragment delivered error ``$err''";
  }
  
  sub _load_text {
    my $fn = shift;
    local *F;
    unless (open F, $fn) {
      $ERROR = "Couldn't open file $fn: $!";
      return undef;
    }
    local $/;
    <F>;
  }
  
  sub _is_clean {
    my $z;
    eval { ($z = join('', @_)), eval '#' . substr($z,0,0); 1 }   # LOD
  }
  
  sub _unconditionally_untaint {
    for (@_) {
      ($_) = /(.*)/s;
    }
  }
  
  {
    my $seqno = 0;
    sub _gensym {
      __PACKAGE__ . '::GEN' . $seqno++;
    }
    sub _scrubpkg {
      my $s = shift;
      $s =~ s/^Text::Template:://;
      no strict 'refs';
      my $hash = $Text::Template::{$s."::"};
      foreach my $key (keys %$hash) {
        undef $hash->{$key};
      }
    }
  }
    
  # Given a hashful of variables (or a list of such hashes)
  # install the variables into the specified package,
  # overwriting whatever variables were there before.
  sub _install_hash {
    my $hashlist = shift;
    my $dest = shift;
    if (UNIVERSAL::isa($hashlist, 'HASH')) {
      $hashlist = [$hashlist];
    }
    my $hash;
    foreach $hash (@$hashlist) {
      my $name;
      foreach $name (keys %$hash) {
        my $val = $hash->{$name};
        no strict 'refs';
        local *SYM = *{"$ {dest}::$name"};
        if (! defined $val) {
  	delete ${"$ {dest}::"}{$name};
        } elsif (ref $val) {
  	*SYM = $val;
        } else {
   	*SYM = \$val;
        }
      }
    }
  }
  
  sub TTerror { $ERROR }
  
  1;
  
  
  =head1 NAME 
  
  Text::Template - Expand template text with embedded Perl
  
  =head1 VERSION
  
  This file documents C<Text::Template> version B<1.45>
  
  =head1 SYNOPSIS
  
   use Text::Template;
  
  
   $template = Text::Template->new(TYPE => 'FILE',  SOURCE => 'filename.tmpl');
   $template = Text::Template->new(TYPE => 'ARRAY', SOURCE => [ ... ] );
   $template = Text::Template->new(TYPE => 'FILEHANDLE', SOURCE => $fh );
   $template = Text::Template->new(TYPE => 'STRING', SOURCE => '...' );
   $template = Text::Template->new(PREPEND => q{use strict;}, ...);
  
   # Use a different template file syntax:
   $template = Text::Template->new(DELIMITERS => [$open, $close], ...);
  
   $recipient = 'King';
   $text = $template->fill_in();  # Replaces `{$recipient}' with `King'
   print $text;
  
   $T::recipient = 'Josh';
   $text = $template->fill_in(PACKAGE => T);
  
   # Pass many variables explicitly
   $hash = { recipient => 'Abed-Nego',
             friends => [ 'me', 'you' ],
             enemies => { loathsome => 'Bill Gates',
                          fearsome => 'Larry Ellison' },
           };
   $text = $template->fill_in(HASH => $hash, ...);
   # $recipient is Abed-Nego,
   # @friends is ( 'me', 'you' ),
   # %enemies is ( loathsome => ..., fearsome => ... )
  
  
   # Call &callback in case of programming errors in template
   $text = $template->fill_in(BROKEN => \&callback, BROKEN_ARG => $ref, ...);
  
   # Evaluate program fragments in Safe compartment with restricted permissions
   $text = $template->fill_in(SAFE => $compartment, ...);
  
   # Print result text instead of returning it
   $success = $template->fill_in(OUTPUT => \*FILEHANDLE, ...);
  
   # Parse template with different template file syntax:
   $text = $template->fill_in(DELIMITERS => [$open, $close], ...);
   # Note that this is *faster* than using the default delimiters
  
   # Prepend specified perl code to each fragment before evaluating:
   $text = $template->fill_in(PREPEND => q{use strict 'vars';}, ...);
  
   use Text::Template 'fill_in_string';
   $text = fill_in_string( <<EOM, PACKAGE => 'T', ...);
   Dear {$recipient},
   Pay me at once.
          Love, 
           G.V.
   EOM
  
   use Text::Template 'fill_in_file';
   $text = fill_in_file($filename, ...);
  
   # All templates will always have `use strict vars' attached to all fragments
   Text::Template->always_prepend(q{use strict 'vars';});
  
  =head1 DESCRIPTION
  
  This is a library for generating form letters, building HTML pages, or
  filling in templates generally.  A `template' is a piece of text that
  has little Perl programs embedded in it here and there.  When you
  `fill in' a template, you evaluate the little programs and replace
  them with their values.  
  
  You can store a template in a file outside your program.  People can
  modify the template without modifying the program.  You can separate
  the formatting details from the main code, and put the formatting
  parts of the program into the template.  That prevents code bloat and
  encourages functional separation.
  
  =head2 Example
  
  Here's an example of a template, which we'll suppose is stored in the
  file C<formletter.tmpl>:
  
  	Dear {$title} {$lastname},
  
  	It has come to our attention that you are delinquent in your
  	{$monthname[$last_paid_month]} payment.  Please remit
  	${sprintf("%.2f", $amount)} immediately, or your patellae may
  	be needlessly endangered.
  
  			Love,
  
  			Mark "Vizopteryx" Dominus
  
  
  The result of filling in this template is a string, which might look
  something like this:
  
  	Dear Mr. Gates,
  
  	It has come to our attention that you are delinquent in your
  	February payment.  Please remit
  	$392.12 immediately, or your patellae may
  	be needlessly endangered.
  
  
  			Love,
  
  			Mark "Vizopteryx" Dominus
  
  Here is a complete program that transforms the example
  template into the example result, and prints it out:
  
  	use Text::Template;
  
  	my $template = Text::Template->new(SOURCE => 'formletter.tmpl')
  	  or die "Couldn't construct template: $Text::Template::ERROR";
  
  	my @monthname = qw(January February March April May June
                             July August September October November December);
  	my %vars = (title => 'Mr.',
  		    firstname => 'Bill',
  		    lastname => 'Gates',
  		    last_paid_month => 1,   # February
  		    amount => 392.12,
  		    monthname => \@monthname,
  		   );
  
  	my $result = $template->fill_in(HASH => \%vars);
  
  	if (defined $result) { print $result }
  	else { die "Couldn't fill in template: $Text::Template::ERROR" }
  
  
  =head2 Philosophy
  
  When people make a template module like this one, they almost always
  start by inventing a special syntax for substitutions.  For example,
  they build it so that a string like C<%%VAR%%> is replaced with the
  value of C<$VAR>.  Then they realize the need extra formatting, so
  they put in some special syntax for formatting.  Then they need a
  loop, so they invent a loop syntax.  Pretty soon they have a new
  little template language.
  
  This approach has two problems: First, their little language is
  crippled. If you need to do something the author hasn't thought of,
  you lose.  Second: Who wants to learn another language?  You already
  know Perl, so why not use it?
  
  C<Text::Template> templates are programmed in I<Perl>.  You embed Perl
  code in your template, with C<{> at the beginning and C<}> at the end.
  If you want a variable interpolated, you write it the way you would in
  Perl.  If you need to make a loop, you can use any of the Perl loop
  constructions.  All the Perl built-in functions are available.
  
  =head1 Details
  
  =head2 Template Parsing
  
  The C<Text::Template> module scans the template source.  An open brace
  C<{> begins a program fragment, which continues until the matching
  close brace C<}>.  When the template is filled in, the program
  fragments are evaluated, and each one is replaced with the resulting
  value to yield the text that is returned.
  
  A backslash C<\> in front of a brace (or another backslash that is in
  front of a brace) escapes its special meaning.  The result of filling
  out this template:
  
  	\{ The sum of 1 and 2 is {1+2}  \}
  
  is
  
  	{ The sum of 1 and 2 is 3  }
  
  If you have an unmatched brace, C<Text::Template> will return a
  failure code and a warning about where the problem is.  Backslashes
  that do not precede a brace are passed through unchanged.  If you have
  a template like this:
  
  	{ "String that ends in a newline.\n" }
  
  The backslash inside the string is passed through to Perl unchanged,
  so the C<\n> really does turn into a newline.  See the note at the end
  for details about the way backslashes work.  Backslash processing is
  I<not> done when you specify alternative delimiters with the
  C<DELIMITERS> option.  (See L<"Alternative Delimiters">, below.)
  
  Each program fragment should be a sequence of Perl statements, which
  are evaluated the usual way.  The result of the last statement
  executed will be evaluted in scalar context; the result of this
  statement is a string, which is interpolated into the template in
  place of the program fragment itself.
  
  The fragments are evaluated in order, and side effects from earlier
  fragments will persist into later fragments:
  
  	{$x = @things; ''}The Lord High Chamberlain has gotten {$x}
  	things for me this year.  
  	{ $diff = $x - 17; 
  	  $more = 'more'
  	  if ($diff == 0) {
  	    $diff = 'no';
  	  } elsif ($diff < 0) {
  	    $more = 'fewer';
  	  } 
            '';
  	} 
  	That is {$diff} {$more} than he gave me last year.
  
  The value of C<$x> set in the first line will persist into the next
  fragment that begins on the third line, and the values of C<$diff> and
  C<$more> set in the second fragment will persist and be interpolated
  into the last line.  The output will look something like this:
  
  	The Lord High Chamberlain has gotten 42
  	things for me this year.  
  
  	That is 25 more than he gave me last year.
  
  That is all the syntax there is.  
  
  =head2 The C<$OUT> variable
  
  There is one special trick you can play in a template.  Here is the
  motivation for it:  Suppose you are going to pass an array, C<@items>,
  into the template, and you want the template to generate a bulleted
  list with a header, like this:
  
  	Here is a list of the things I have got for you since 1907:
  	  * Ivory
  	  * Apes
  	  * Peacocks
  	  * ...
  
  One way to do it is with a template like this:
  
  	Here is a list of the things I have got for you since 1907:
  	{ my $blist = '';
            foreach $i (@items) {
              $blist .= qq{  * $i\n};
            }    
            $blist;
          } 
  
  Here we construct the list in a variable called C<$blist>, which we
  return at the end.  This is a little cumbersome.  There is a shortcut.
  
  Inside of templates, there is a special variable called C<$OUT>.
  Anything you append to this variable will appear in the output of the
  template.  Also, if you use C<$OUT> in a program fragment, the normal
  behavior, of replacing the fragment with its return value, is
  disabled; instead the fragment is replaced with the value of C<$OUT>.
  This means that you can write the template above like this:
  
  	Here is a list of the things I have got for you since 1907:
  	{ foreach $i (@items) {
              $OUT .= "  * $i\n";
            }    
          } 
  
  C<$OUT> is reinitialized to the empty string at the start of each
  program fragment.  It is private to C<Text::Template>, so 
  you can't use a variable named C<$OUT> in your template without
  invoking the special behavior.
  
  =head2 General Remarks
  
  All C<Text::Template> functions return C<undef> on failure, and set the
  variable C<$Text::Template::ERROR> to contain an explanation of what
  went wrong.  For example, if you try to create a template from a file
  that does not exist, C<$Text::Template::ERROR> will contain something like:
  
  	Couldn't open file xyz.tmpl: No such file or directory
  
  =head2 C<new>
  
  	$template = new Text::Template ( TYPE => ..., SOURCE => ... );
  
  This creates and returns a new template object.  C<new> returns
  C<undef> and sets C<$Text::Template::ERROR> if it can't create the
  template object.  C<SOURCE> says where the template source code will
  come from.  C<TYPE> says what kind of object the source is.
  
  The most common type of source is a file:
  
  	new Text::Template ( TYPE => 'FILE', SOURCE => $filename );
  
  This reads the template from the specified file.  The filename is
  opened with the Perl C<open> command, so it can be a pipe or anything
  else that makes sense with C<open>.
  
  The C<TYPE> can also be C<STRING>, in which case the C<SOURCE> should
  be a string:
  
  	new Text::Template ( TYPE => 'STRING', 
                               SOURCE => "This is the actual template!" );
  
  The C<TYPE> can be C<ARRAY>, in which case the source should be a
  reference to an array of strings.  The concatenation of these strings
  is the template:
  
  	new Text::Template ( TYPE => 'ARRAY', 
                               SOURCE => [ "This is ", "the actual", 
                                           " template!",
                                         ]
                             );
  
  The C<TYPE> can be FILEHANDLE, in which case the source should be an
  open filehandle (such as you got from the C<FileHandle> or C<IO::*>
  packages, or a glob, or a reference to a glob).  In this case
  C<Text::Template> will read the text from the filehandle up to
  end-of-file, and that text is the template:
  
  	# Read template source code from STDIN:
  	new Text::Template ( TYPE => 'FILEHANDLE', 
                               SOURCE => \*STDIN  );
  
  
  If you omit the C<TYPE> attribute, it's taken to be C<FILE>.
  C<SOURCE> is required.  If you omit it, the program will abort.
  
  The words C<TYPE> and C<SOURCE> can be spelled any of the following ways:
  
  	TYPE	SOURCE
  	Type	Source
  	type	source
  	-TYPE	-SOURCE
  	-Type	-Source
  	-type	-source
  
  Pick a style you like and stick with it.
  
  =over 4
  
  =item C<DELIMITERS>
  
  You may also add a C<DELIMITERS> option.  If this option is present,
  its value should be a reference to an array of two strings.  The first
  string is the string that signals the beginning of each program
  fragment, and the second string is the string that signals the end of
  each program fragment.  See L<"Alternative Delimiters">, below.
  
  =item C<UNTAINT>
  
  If your program is running in taint mode, you may have problems if
  your templates are stored in files.  Data read from files is
  considered 'untrustworthy', and taint mode will not allow you to
  evaluate the Perl code in the file.  (It is afraid that a malicious
  person might have tampered with the file.)
  
  In some environments, however, local files are trustworthy.  You can
  tell C<Text::Template> that a certain file is trustworthy by supplying
  C<UNTAINT =E<gt> 1> in the call to C<new>.  This will tell
  C<Text::Template> to disable taint checks on template code that has
  come from a file, as long as the filename itself is considered
  trustworthy.  It will also disable taint checks on template code that
  comes from a filehandle.  When used with C<TYPE =E<gt> 'string'> or C<TYPE
  =E<gt> 'array'>, it has no effect.
  
  See L<perlsec> for more complete information about tainting.
  
  Thanks to Steve Palincsar, Gerard Vreeswijk, and Dr. Christoph Baehr
  for help with this feature.
  
  =item C<PREPEND>
  
  This option is passed along to the C<fill_in> call unless it is
  overridden in the arguments to C<fill_in>.  See L<C<PREPEND> feature
  and using C<strict> in templates> below.
  
  =item C<BROKEN>
  
  This option is passed along to the C<fill_in> call unless it is
  overridden in the arguments to C<fill_in>.  See L<C<BROKEN>> below.
  
  =back
  
  =head2 C<compile>
  
  	$template->compile()
  
  Loads all the template text from the template's source, parses and
  compiles it.  If successful, returns true; otherwise returns false and
  sets C<$Text::Template::ERROR>.  If the template is already compiled,
  it returns true and does nothing.  
  
  You don't usually need to invoke this function, because C<fill_in>
  (see below) compiles the template if it isn't compiled already.
  
  If there is an argument to this function, it must be a reference to an
  array containing alternative delimiter strings.  See C<"Alternative
  Delimiters">, below.
  
  =head2 C<fill_in>
  
  	$template->fill_in(OPTIONS);
  
  Fills in a template.  Returns the resulting text if successful.
  Otherwise, returns C<undef>  and sets C<$Text::Template::ERROR>.
  
  The I<OPTIONS> are a hash, or a list of key-value pairs.  You can
  write the key names in any of the six usual styles as above; this
  means that where this manual says C<PACKAGE> (for example) you can
  actually use any of
  
  	PACKAGE Package package -PACKAGE -Package -package
  
  Pick a style you like and stick with it.  The all-lowercase versions
  may yield spurious warnings about
  
  	Ambiguous use of package => resolved to "package"
  
  so you might like to avoid them and use the capitalized versions.
  
  At present, there are eight legal options:  C<PACKAGE>, C<BROKEN>,
  C<BROKEN_ARG>, C<SAFE>, C<HASH>, C<OUTPUT>, and C<DELIMITERS>.
  
  =over 4
  
  =item C<PACKAGE>
  
  C<PACKAGE> specifies the name of a package in which the program
  fragments should be evaluated.  The default is to use the package from
  which C<fill_in> was called.  For example, consider this template:
  
  	The value of the variable x is {$x}.
  
  If you use C<$template-E<gt>fill_in(PACKAGE =E<gt> 'R')> , then the C<$x> in
  the template is actually replaced with the value of C<$R::x>.  If you
  omit the C<PACKAGE> option, C<$x> will be replaced with the value of
  the C<$x> variable in the package that actually called C<fill_in>.
  
  You should almost always use C<PACKAGE>.  If you don't, and your
  template makes changes to variables, those changes will be propagated
  back into the main program.  Evaluating the template in a private
  package helps prevent this.  The template can still modify variables
  in your program if it wants to, but it will have to do so explicitly.
  See the section at the end on `Security'.
  
  Here's an example of using C<PACKAGE>:
  
  	Your Royal Highness,
  
  	Enclosed please find a list of things I have gotten
  	for you since 1907:
  
  	{ foreach $item (@items) {
              $item_no++;
  	    $OUT .= " $item_no. \u$item\n";
  	  }
  	}
  
  	Signed,
  	Lord High Chamberlain
  
  We want to pass in an array which will be assigned to the array
  C<@items>.  Here's how to do that:
  
  
  	@items = ('ivory', 'apes', 'peacocks', );
  	$template->fill_in();
  
  This is not very safe.  The reason this isn't as safe is that if you
  had a variable named C<$item_no> in scope in your program at the point
  you called C<fill_in>, its value would be clobbered by the act of
  filling out the template.  The problem is the same as if you had
  written a subroutine that used those variables in the same way that
  the template does.  (C<$OUT> is special in templates and is always
  safe.)
  
  One solution to this is to make the C<$item_no> variable private to the
  template by declaring it with C<my>.  If the template does this, you
  are safe.
  
  But if you use the C<PACKAGE> option, you will probably be safe even
  if the template does I<not> declare its variables with C<my>:
  
  	@Q::items = ('ivory', 'apes', 'peacocks', );
  	$template->fill_in(PACKAGE => 'Q');
  
  In this case the template will clobber the variable C<$Q::item_no>,
  which is not related to the one your program was using.
  
  Templates cannot affect variables in the main program that are
  declared with C<my>, unless you give the template references to those
  variables.
  
  =item C<HASH>
  
  You may not want to put the template variables into a package.
  Packages can be hard to manage:  You can't copy them, for example.
  C<HASH> provides an alternative.  
  
  The value for C<HASH> should be a reference to a hash that maps
  variable names to values.  For example, 
  
  	$template->fill_in(HASH => { recipient => "The King",
  				     items => ['gold', 'frankincense', 'myrrh'],
  	                             object => \$self,
  				   });
  
  will fill out the template and use C<"The King"> as the value of
  C<$recipient> and the list of items as the value of C<@items>.  Note
  that we pass an array reference, but inside the template it appears as
  an array.  In general, anything other than a simple string or number
  should be passed by reference.
  
  We also want to pass an object, which is in C<$self>; note that we
  pass a reference to the object, C<\$self> instead.  Since we've passed
  a reference to a scalar, inside the template the object appears as
  C<$object>.  
  
  The full details of how it works are a little involved, so you might
  want to skip to the next section.
  
  Suppose the key in the hash is I<key> and the value is I<value>.  
  
  =over 4
  
  =item *
  
  If the I<value> is C<undef>, then any variables named C<$key>,
  C<@key>, C<%key>, etc., are undefined.  
  
  =item *
  
  If the I<value> is a string or a number, then C<$key> is set to that
  value in the template.
  
  =item *
  
  For anything else, you must pass a reference.
  
  If the I<value> is a reference to an array, then C<@key> is set to
  that array.  If the I<value> is a reference to a hash, then C<%key> is
  set to that hash.  Similarly if I<value> is any other kind of
  reference.  This means that
  
  	var => "foo"
  
  and
  
  	var => \"foo"
  
  have almost exactly the same effect.  (The difference is that in the
  former case, the value is copied, and in the latter case it is
  aliased.)  
  
  =item *
  
  In particular, if you want the template to get an object or any kind,
  you must pass a reference to it:
  
  	$template->fill_in(HASH => { database_handle => \$dbh, ... });
  
  If you do this, the template will have a variable C<$database_handle>
  which is the database handle object.  If you leave out the C<\>, the
  template will have a hash C<%database_handle>, which exposes the
  internal structure of the database handle object; you don't want that.
  
  =back
  
  Normally, the way this works is by allocating a private package,
  loading all the variables into the package, and then filling out the
  template as if you had specified that package.  A new package is
  allocated each time.  However, if you I<also> use the C<PACKAGE>
  option, C<Text::Template> loads the variables into the package you
  specified, and they stay there after the call returns.  Subsequent
  calls to C<fill_in> that use the same package will pick up the values
  you loaded in.
  
  If the argument of C<HASH> is a reference to an array instead of a
  reference to a hash, then the array should contain a list of hashes
  whose contents are loaded into the template package one after the
  other.  You can use this feature if you want to combine several sets
  of variables.  For example, one set of variables might be the defaults
  for a fill-in form, and the second set might be the user inputs, which
  override the defaults when they are present:
  
  	$template->fill_in(HASH => [\%defaults, \%user_input]);
  
  You can also use this to set two variables with the same name:
  
  	$template->fill_in(HASH => [{ v => "The King" },
                                      { v => [1,2,3] },
  	                           ]
                            );
  
  This sets C<$v> to C<"The King"> and C<@v> to C<(1,2,3)>.	
  
  =item C<BROKEN>
  
  If any of the program fragments fails to compile or aborts for any
  reason, and you have set the C<BROKEN> option to a function reference,
  C<Text::Template> will invoke the function.  This function is called
  the I<C<BROKEN> function>.  The C<BROKEN> function will tell
  C<Text::Template> what to do next.  
  
  If the C<BROKEN> function returns C<undef>, C<Text::Template> will
  immediately abort processing the template and return the text that it
  has accumulated so far.  If your function does this, it should set a
  flag that you can examine after C<fill_in> returns so that you can
  tell whether there was a premature return or not. 
  
  If the C<BROKEN> function returns any other value, that value will be
  interpolated into the template as if that value had been the return
  value of the program fragment to begin with.  For example, if the
  C<BROKEN> function returns an error string, the error string will be
  interpolated into the output of the template in place of the program
  fragment that cased the error.
  
  If you don't specify a C<BROKEN> function, C<Text::Template> supplies
  a default one that returns something like
  
  	Program fragment delivered error ``Illegal division by 0 at
  	template line 37''
  
  (Note that the format of this message has changed slightly since
  version 1.31.)  The return value of the C<BROKEN> function is
  interpolated into the template at the place the error occurred, so
  that this template:
  
  	(3+4)*5 = { 3+4)*5 }
  
  yields this result:
  
  	(3+4)*5 = Program fragment delivered error ``syntax error at template line 1''
  
  If you specify a value for the C<BROKEN> attribute, it should be a
  reference to a function that C<fill_in> can call instead of the
  default function.
  
  C<fill_in> will pass a hash to the C<broken> function.
  The hash will have at least these three members:
  
  =over 4
  
  =item C<text>
  
  The source code of the program fragment that failed
  
  =item C<error>
  
  The text of the error message (C<$@>) generated by eval.
  
  The text has been modified to omit the trailing newline and to include
  the name of the template file (if there was one).  The line number
  counts from the beginning of the template, not from the beginning of
  the failed program fragment.
  
  =item C<lineno>
  
  The line number of the template at which the program fragment began.
  
  =back
  
  There may also be an C<arg> member.  See C<BROKEN_ARG>, below
  
  =item C<BROKEN_ARG>
  
  If you supply the C<BROKEN_ARG> option to C<fill_in>, the value of the
  option is passed to the C<BROKEN> function whenever it is called.  The
  default C<BROKEN> function ignores the C<BROKEN_ARG>, but you can
  write a custom C<BROKEN> function that uses the C<BROKEN_ARG> to get
  more information about what went wrong. 
  
  The C<BROKEN> function could also use the C<BROKEN_ARG> as a reference
  to store an error message or some other information that it wants to
  communicate back to the caller.  For example:
  
  	$error = '';
  
  	sub my_broken {	
  	   my %args = @_;
  	   my $err_ref = $args{arg};
  	   ...
  	   $$err_ref = "Some error message";
  	   return undef;
  	}
  
  	$template->fill_in(BROKEN => \&my_broken,
  			   BROKEN_ARG => \$error,
  			  );
  
  	if ($error) {
  	  die "It didn't work: $error";
  	}
  
  If one of the program fragments in the template fails, it will call
  the C<BROKEN> function, C<my_broken>, and pass it the C<BROKEN_ARG>,
  which is a reference to C<$error>.  C<my_broken> can store an error
  message into C<$error> this way.  Then the function that called
  C<fill_in> can see if C<my_broken> has left an error message for it
  to find, and proceed accordingly.
  
  =item C<SAFE>
  
  If you give C<fill_in> a C<SAFE> option, its value should be a safe
  compartment object from the C<Safe> package.  All evaluation of
  program fragments will be performed in this compartment.  See L<Safe>
  for full details about such compartments and how to restrict the
  operations that can be performed in them.
  
  If you use the C<PACKAGE> option with C<SAFE>, the package you specify
  will be placed into the safe compartment and evaluation will take
  place in that package as usual.  
  
  If not, C<SAFE> operation is a little different from the default.
  Usually, if you don't specify a package, evaluation of program
  fragments occurs in the package from which the template was invoked.
  But in C<SAFE> mode the evaluation occurs inside the safe compartment
  and cannot affect the calling package.  Normally, if you use C<HASH>
  without C<PACKAGE>, the hash variables are imported into a private,
  one-use-only package.  But if you use C<HASH> and C<SAFE> together
  without C<PACKAGE>, the hash variables will just be loaded into the
  root namespace of the C<Safe> compartment.
  
  =item C<OUTPUT>
  
  If your template is going to generate a lot of text that you are just
  going to print out again anyway,  you can save memory by having
  C<Text::Template> print out the text as it is generated instead of
  making it into a big string and returning the string.  If you supply
  the C<OUTPUT> option to C<fill_in>, the value should be a filehandle.
  The generated text will be printed to this filehandle as it is
  constructed.  For example:
  
  	$template->fill_in(OUTPUT => \*STDOUT, ...);
  
  fills in the C<$template> as usual, but the results are immediately
  printed to STDOUT.  This may result in the output appearing more
  quickly than it would have otherwise.
  
  If you use C<OUTPUT>, the return value from C<fill_in> is still true on
  success and false on failure, but the complete text is not returned to
  the caller.
  
  =item C<PREPEND>
  
  You can have some Perl code prepended automatically to the beginning
  of every program fragment.  See L<C<PREPEND> feature and using
  C<strict> in templates> below.
  
  =item C<DELIMITERS>
  
  If this option is present, its value should be a reference to a list
  of two strings.  The first string is the string that signals the
  beginning of each program fragment, and the second string is the
  string that signals the end of each program fragment.  See
  L<"Alternative Delimiters">, below.  
  
  If you specify C<DELIMITERS> in the call to C<fill_in>, they override
  any delimiters you set when you created the template object with
  C<new>. 
  
  =back
  
  =head1 Convenience Functions
  
  =head2 C<fill_this_in>
  
  The basic way to fill in a template is to create a template object and
  then call C<fill_in> on it.   This is useful if you want to fill in
  the same template more than once.
  
  In some programs, this can be cumbersome.  C<fill_this_in> accepts a
  string, which contains the template, and a list of options, which are
  passed to C<fill_in> as above.  It constructs the template object for
  you, fills it in as specified, and returns the results.  It returns
  C<undef> and sets C<$Text::Template::ERROR> if it couldn't generate
  any results.
  
  An example:
  
  	$Q::name = 'Donald';
  	$Q::amount = 141.61;
  	$Q::part = 'hyoid bone';
  
  	$text = Text::Template->fill_this_in( <<'EOM', PACKAGE => Q);
  	Dear {$name},
  	You owe me \\${sprintf('%.2f', $amount)}.  
  	Pay or I will break your {$part}.
  		Love,
  		Grand Vizopteryx of Irkutsk.
  	EOM
  
  Notice how we included the template in-line in the program by using a
  `here document' with the C<E<lt>E<lt>> notation.
  
  C<fill_this_in> is a deprecated feature.  It is only here for
  backwards compatibility, and may be removed in some far-future version
  in C<Text::Template>.  You should use C<fill_in_string> instead.  It
  is described in the next section.
  
  =head2 C<fill_in_string>
  
  It is stupid that C<fill_this_in> is a class method.  It should have
  been just an imported function, so that you could omit the
  C<Text::Template-E<gt>> in the example above.  But I made the mistake
  four years ago and it is too late to change it.
  
  C<fill_in_string> is exactly like C<fill_this_in> except that it is
  not a method and you can omit the C<Text::Template-E<gt>> and just say
  
  	print fill_in_string(<<'EOM', ...);
  	Dear {$name},
  	  ...
  	EOM
  
  To use C<fill_in_string>, you need to say
  
  	use Text::Template 'fill_in_string';
  
  at the top of your program.   You should probably use
  C<fill_in_string> instead of C<fill_this_in>.
  
  =head2 C<fill_in_file>
  
  If you import C<fill_in_file>, you can say
  
  	$text = fill_in_file(filename, ...);
  
  The C<...> are passed to C<fill_in> as above.  The filename is the
  name of the file that contains the template you want to fill in.  It
  returns the result text. or C<undef>, as usual.
  
  If you are going to fill in the same file more than once in the same
  program you should use the longer C<new> / C<fill_in> sequence instead.
  It will be a lot faster because it only has to read and parse the file
  once.
  
  =head2 Including files into templates
  
  People always ask for this.  ``Why don't you have an include
  function?'' they want to know.  The short answer is this is Perl, and
  Perl already has an include function.  If you want it, you can just put
  
  	{qx{cat filename}}
  
  into your template.  VoilE<agrave>.
  
  If you don't want to use C<cat>, you can write a little four-line
  function that opens a file and dumps out its contents, and call it
  from the template.  I wrote one for you.  In the template, you can say
  
  	{Text::Template::_load_text(filename)}
  
  If that is too verbose, here is a trick.  Suppose the template package
  that you are going to be mentioning in the C<fill_in> call is package
  C<Q>.  Then in the main program, write
  
  	*Q::include = \&Text::Template::_load_text;
  
  This imports the C<_load_text> function into package C<Q> with the
  name C<include>.  From then on, any template that you fill in with
  package C<Q> can say
  
  	{include(filename)}
  
  to insert the text from the named file at that point.  If you are
  using the C<HASH> option instead, just put C<include =E<gt>
  \&Text::Template::_load_text> into the hash instead of importing it
  explicitly.
  
  Suppose you don't want to insert a plain text file, but rather you
  want to include one template within another?  Just use C<fill_in_file>
  in the template itself:
  
  	{Text::Template::fill_in_file(filename)}
  
  You can do the same importing trick if this is too much to type.
  
  =head1 Miscellaneous
  
  =head2 C<my> variables
  
  People are frequently surprised when this doesn't work:
  
  	my $recipient = 'The King';
  	my $text = fill_in_file('formletter.tmpl');
  
  The text C<The King> doesn't get into the form letter.  Why not?
  Because C<$recipient> is a C<my> variable, and the whole point of
  C<my> variables is that they're private and inaccessible except in the
  scope in which they're declared.  The template is not part of that
  scope, so the template can't see C<$recipient>.  
  
  If that's not the behavior you want, don't use C<my>.  C<my> means a
  private variable, and in this case you don't want the variable to be
  private.  Put the variables into package variables in some other
  package, and use the C<PACKAGE> option to C<fill_in>:
  
  	$Q::recipient = $recipient;
  	my $text = fill_in_file('formletter.tmpl', PACKAGE => 'Q');
  	
  
  or pass the names and values in a hash with the C<HASH> option:
  
  	my $text = fill_in_file('formletter.tmpl', HASH => { recipient => $recipient });
  
  =head2 Security Matters
  
  All variables are evaluated in the package you specify with the
  C<PACKAGE> option of C<fill_in>.  if you use this option, and if your
  templates don't do anything egregiously stupid, you won't have to
  worry that evaluation of the little programs will creep out into the
  rest of your program and wreck something.
  
  Nevertheless, there's really no way (except with C<Safe>) to protect
  against a template that says
  
  	{ $Important::Secret::Security::Enable = 0; 
  	  # Disable security checks in this program 
  	}
  
  or
  
  	{ $/ = "ho ho ho";   # Sabotage future uses of <FH>.
  	  # $/ is always a global variable
  	}
  
  or even
  
  	{ system("rm -rf /") }
  
  so B<don't> go filling in templates unless you're sure you know what's
  in them.  If you're worried, or you can't trust the person who wrote
  the template, use the C<SAFE> option.
  
  A final warning: program fragments run a small risk of accidentally
  clobbering local variables in the C<fill_in> function itself.  These
  variables all have names that begin with C<$fi_>, so if you stay away
  from those names you'll be safe.  (Of course, if you're a real wizard
  you can tamper with them deliberately for exciting effects; this is
  actually how C<$OUT> works.)  I can fix this, but it will make the
  package slower to do it, so I would prefer not to.  If you are worried
  about this, send me mail and I will show you what to do about it.
  
  =head2 Alternative Delimiters
  
  Lorenzo Valdettaro pointed out that if you are using C<Text::Template>
  to generate TeX output, the choice of braces as the program fragment
  delimiters makes you suffer suffer suffer.  Starting in version 1.20,
  you can change the choice of delimiters to something other than curly
  braces.
  
  In either the C<new()> call or the C<fill_in()> call, you can specify
  an alternative set of delimiters with the C<DELIMITERS> option.  For
  example, if you would like code fragments to be delimited by C<[@-->
  and C<--@]> instead of C<{> and C<}>, use
  
  	... DELIMITERS => [ '[@--', '--@]' ], ...
  
  Note that these delimiters are I<literal strings>, not regexes.  (I
  tried for regexes, but it complicates the lexical analysis too much.)
  Note also that C<DELIMITERS> disables the special meaning of the
  backslash, so if you want to include the delimiters in the literal
  text of your template file, you are out of luck---it is up to you to
  choose delimiters that do not conflict with what you are doing.  The
  delimiter strings may still appear inside of program fragments as long
  as they nest properly.  This means that if for some reason you
  absolutely must have a program fragment that mentions one of the
  delimiters, like this:
  
  	[@--
  		print "Oh no, a delimiter: --@]\n"
  	--@]
  
  you may be able to make it work by doing this instead:
  
  	[@--
  		# Fake matching delimiter in a comment: [@--
  		print "Oh no, a delimiter: --@]\n"
  	--@]
  
  It may be safer to choose delimiters that begin with a newline
  character.  
  
  Because the parsing of templates is simplified by the absence of
  backslash escapes, using alternative C<DELIMITERS> may speed up the
  parsing process by 20-25%.  This shows that my original choice of C<{>
  and C<}> was very bad. 
  
  =head2 C<PREPEND> feature and using C<strict> in templates
  
  Suppose you would like to use C<strict> in your templates to detect
  undeclared variables and the like.  But each code fragment is a
  separate lexical scope, so you have to turn on C<strict> at the top of
  each and every code fragment:
  
  	{ use strict;
  	  use vars '$foo';
  	  $foo = 14;
  	  ...
  	}
  
  	...
  
  	{ # we forgot to put `use strict' here
  	  my $result = $boo + 12;    # $boo is misspelled and should be $foo
  	  # No error is raised on `$boo'
  	}
  
  Because we didn't put C<use strict> at the top of the second fragment,
  it was only active in the first fragment, and we didn't get any
  C<strict> checking in the second fragment.  Then we mispelled C<$foo>
  and the error wasn't caught.  
  
  C<Text::Template> version 1.22 and higher has a new feature to make
  this easier.  You can specify that any text at all be automatically
  added to the beginning of each program fragment.  
  
  When you make a call to C<fill_in>, you can specify a
  
  	PREPEND => 'some perl statements here'
  
  option; the statements will be prepended to each program fragment for
  that one call only.  Suppose that the C<fill_in> call included a
  
  	PREPEND => 'use strict;'
  
  option, and that the template looked like this:
  
  	{ use vars '$foo';
  	  $foo = 14;
  	  ...
  	}
  
  	...
  
  	{ my $result = $boo + 12;    # $boo is misspelled and should be $foo
  	  ...
  	}
  
  The code in the second fragment would fail, because C<$boo> has not
  been declared.  C<use strict> was implied, even though you did not
  write it explicitly, because the C<PREPEND> option added it for you
  automatically.
  
  There are two other ways to do this.  At the time you create the
  template object with C<new>, you can also supply a C<PREPEND> option,
  in which case the statements will be prepended each time you fill in
  that template.  If the C<fill_in> call has its own C<PREPEND> option,
  this overrides the one specified at the time you created the
  template.  Finally, you can make the class method call
  
  	Text::Template->always_prepend('perl statements');
  
  If you do this, then call calls to C<fill_in> for I<any> template will
  attach the perl statements to the beginning of each program fragment,
  except where overridden by C<PREPEND> options to C<new> or C<fill_in>.
  
  =head2 Prepending in Derived Classes
  
  This section is technical, and you should skip it on the first few
  readings. 
  
  Normally there are three places that prepended text could come from.
  It could come from the C<PREPEND> option in the C<fill_in> call, from
  the C<PREPEND> option in the C<new> call that created the template
  object, or from the argument of the C<always_prepend> call.
  C<Text::Template> looks for these three things in order and takes the
  first one that it finds.
  
  In a subclass of C<Text::Template>, this last possibility is
  ambiguous.  Suppose C<S> is a subclass of C<Text::Template>.  Should 
  
  	Text::Template->always_prepend(...);
  
  affect objects in class C<Derived>?  The answer is that you can have it
  either way.  
  
  The C<always_prepend> value for C<Text::Template> is normally stored
  in  a hash variable named C<%GLOBAL_PREPEND> under the key
  C<Text::Template>.  When C<Text::Template> looks to see what text to
  prepend, it first looks in the template object itself, and if not, it
  looks in C<$GLOBAL_PREPEND{I<class>}> where I<class> is the class to
  which the template object belongs.  If it doesn't find any value, it
  looks in C<$GLOBAL_PREPEND{'Text::Template'}>.  This means that
  objects in class C<Derived> I<will> be affected by
  
  	Text::Template->always_prepend(...);
  
  I<unless> there is also a call to
  
  	Derived->always_prepend(...);
  
  So when you're designing your derived class, you can arrange to have
  your objects ignore C<Text::Template::always_prepend> calls by simply
  putting C<Derived-E<gt>always_prepend('')> at the top of your module.
  
  Of course, there is also a final escape hatch: Templates support a
  C<prepend_text> that is used to look up the appropriate text to be
  prepended at C<fill_in> time.  Your derived class can override this
  method to get an arbitrary effect.
  
  =head2 JavaScript
  
  Jennifer D. St Clair asks:
  
  	> Most of my pages contain JavaScript and Stylesheets.
          > How do I change the template identifier?  
  
  Jennifer is worried about the braces in the JavaScript being taken as
  the delimiters of the Perl program fragments.  Of course, disaster
  will ensue when perl tries to evaluate these as if they were Perl
  programs.  The best choice is to find some unambiguous delimiter
  strings that you can use in your template instead of curly braces, and
  then use the C<DELIMITERS> option.  However, if you can't do this for
  some reason, there are  two easy workarounds:
  
  1. You can put C<\> in front of C<{>, C<}>, or C<\> to remove its
  special meaning.  So, for example, instead of
  
  	    if (br== "n3") { 
  		// etc.
  	    }
  
  you can put
  
  	    if (br== "n3") \{ 
  		// etc.
  	    \}
  
  and it'll come out of the template engine the way you want.
  
  But here is another method that is probably better.  To see how it
  works, first consider what happens if you put this into a template:
  
  	    { 'foo' }
  
  Since it's in braces, it gets evaluated, and obviously, this is going
  to turn into
  
  	    foo
  
  So now here's the trick: In Perl, C<q{...}> is the same as C<'...'>.
  So if we wrote
  
  	    {q{foo}}
  
  it would turn into 
  
  	    foo
  
  So for your JavaScript, just write
  
  	    {q{if (br== "n3") { 
  	  	 // etc.
  	       }}
  	    }
  
  and it'll come out as
  
  	      if (br== "n3") { 
  	  	  // etc.
  	      }
  
  which is what you want.
  
  
  =head2 Shut Up!
  
  People sometimes try to put an initialization section at the top of
  their templates, like this:
  
  	{ ...
  	  $var = 17;
  	}
  
  Then they complain because there is a C<17> at the top of the output
  that they didn't want to have there.  
  
  Remember that a program fragment is replaced with its own return
  value, and that in Perl the return value of a code block is the value
  of the last expression that was evaluated, which in this case is 17.
  If it didn't do that, you wouldn't be able to write C<{$recipient}>
  and have the recipient filled in.
  
  To prevent the 17 from appearing in the output is very simple:
  
  	{ ...
  	  $var = 17;
  	  '';
  	}
  
  Now the last expression evaluated yields the empty string, which is
  invisible.  If you don't like the way this looks, use
  
  	{ ...
  	  $var = 17;
  	  ($SILENTLY);
  	}
  
  instead.  Presumably, C<$SILENTLY> has no value, so nothing will be
  interpolated.  This is what is known as a `trick'.
  
  =head2 Compatibility
  
  Every effort has been made to make this module compatible with older
  versions.  The only known exceptions follow:
  
  The output format of the default C<BROKEN> subroutine has changed
  twice, most recently between versions 1.31 and 1.40.
  
  Starting in version 1.10, the C<$OUT> variable is arrogated for a
  special meaning.  If you had templates before version 1.10 that
  happened to use a variable named C<$OUT>, you will have to change them
  to use some other variable or all sorts of strangeness will result.
  
  Between versions 0.1b and 1.00 the behavior of the \ metacharacter
  changed.  In 0.1b, \\ was special everywhere, and the template
  processor always replaced it with a single backslash before passing
  the code to Perl for evaluation.  The rule now is more complicated but
  probably more convenient.  See the section on backslash processing,
  below, for a full discussion.
  
  =head2 Backslash Processing
  
  In C<Text::Template> beta versions, the backslash was special whenever
  it appeared before a brace or another backslash.  That meant that
  while C<{"\n"}> did indeed generate a newline, C<{"\\"}> did not
  generate a backslash, because the code passed to Perl for evaluation
  was C<"\"> which is a syntax error.  If you wanted a backslash, you
  would have had to write C<{"\\\\"}>.
  
  In C<Text::Template> versions 1.00 through 1.10, there was a bug:
  Backslash was special everywhere.  In these versions, C<{"\n"}>
  generated the letter C<n>.
  
  The bug has been corrected in version 1.11, but I did not go back to
  exactly the old rule, because I did not like the idea of having to
  write C<{"\\\\"}> to get one backslash.  The rule is now more
  complicated to remember, but probably easier to use.  The rule is now:
  Backslashes are always passed to Perl unchanged I<unless> they occur
  as part of a sequence like C<\\\\\\{> or C<\\\\\\}>.  In these
  contexts, they are special; C<\\> is replaced with C<\>, and C<\{> and
  C<\}> signal a literal brace. 
  
  Examples:
  
  	\{ foo \}
  
  is I<not> evaluated, because the C<\> before the braces signals that
  they should be taken literally.  The result in the output looks like this: 
  
  	{ foo }
  
  
  This is a syntax error:
  
  	{ "foo}" }
  
  because C<Text::Template> thinks that the code ends at the first C<}>,
  and then gets upset when it sees the second one.  To make this work
  correctly, use
  
  	{ "foo\}" }
  
  This passes C<"foo}"> to Perl for evaluation.  Note there's no C<\> in
  the evaluated code.  If you really want a C<\> in the evaluated code,
  use
  
  	{ "foo\\\}" }
  
  This passes C<"foo\}"> to Perl for evaluation.
  
  Starting with C<Text::Template> version 1.20, backslash processing is
  disabled if you use the C<DELIMITERS> option to specify alternative
  delimiter strings.
  
  =head2 A short note about C<$Text::Template::ERROR>
  
  In the past some people have fretted about `violating the package
  boundary' by examining a variable inside the C<Text::Template>
  package.  Don't feel this way.  C<$Text::Template::ERROR> is part of
  the published, official interface to this package.  It is perfectly OK
  to inspect this variable.  The interface is not going to change.
  
  If it really, really bothers you, you can import a function called
  C<TTerror> that returns the current value of the C<$ERROR> variable.
  So you can say:
  
  	use Text::Template 'TTerror';
  
  	my $template = new Text::Template (SOURCE => $filename);
  	unless ($template) {
  	  my $err = TTerror;
  	  die "Couldn't make template: $err; aborting";
  	}
  
  I don't see what benefit this has over just doing this:
  
  	use Text::Template;
  
  	my $template = new Text::Template (SOURCE => $filename)
  	  or die "Couldn't make template: $Text::Template::ERROR; aborting";
  
  But if it makes you happy to do it that way, go ahead.
  
  =head2 Sticky Widgets in Template Files
  
  The C<CGI> module provides functions for `sticky widgets', which are
  form input controls that retain their values from one page to the
  next.   Sometimes people want to know how to include these widgets
  into their template output.
  
  It's totally straightforward.  Just call the C<CGI> functions from
  inside the template:
  
  	{ $q->checkbox_group(NAME => 'toppings',
  		  	     LINEBREAK => true,
  			     COLUMNS => 3,
  			     VALUES => \@toppings,
  			    );
  	}
  
  =head2 Automatic preprocessing of program fragments
  
  It may be useful to preprocess the program fragments before they are
  evaluated.  See C<Text::Template::Preprocess> for more details.
  
  =head2 Author
  
  Mark-Jason Dominus, Plover Systems
  
  Please send questions and other remarks about this software to
  C<mjd-perl-template+@plover.com>
  
  You can join a very low-volume (E<lt>10 messages per year) mailing
  list for announcements about this package.  Send an empty note to
  C<mjd-perl-template-request@plover.com> to join.
  
  For updates, visit C<http://www.plover.com/~mjd/perl/Template/>.
  
  =head2 Support?
  
  This software is version 1.45.  It may have bugs.  Suggestions and bug
  reports are always welcome.  Send them to
  C<mjd-perl-template+@plover.com>.  (That is my address, not the address
  of the mailing list.  The mailing list address is a secret.)
  
  =head1 LICENSE
  
      Text::Template version 1.45
      Copyright (C) 2008 Mark Jason Dominus
  
      This program is free software; you can redistribute it and/or
      modify it under the terms of the GNU General Public License as
      published by the Free Software Foundation; either version 2 of the
      License, or (at your option) any later version.  You may also can
      redistribute it and/or modify it under the terms of the Perl
      Artistic License.
  
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received copies of the GNU General Public License
      along with this program; if not, write to the Free Software
      Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  
  
  =head1 THANKS
  
  Many thanks to the following people for offering support,
  encouragement, advice, bug reports, and all the other good stuff.  
  
  David H. Adler /
  Joel Appelbaum /
  Klaus Arnhold /
  AntE<oacute>nio AragE<atilde>o /
  Kevin Atteson /
  Chris.Brezil /
  Mike Brodhead /
  Tom Brown /
  Dr. Frank Bucolo /
  Tim Bunce /
  Juan E. Camacho /
  Itamar Almeida de Carvalho /
  Joseph Cheek /
  Gene Damon /
  San Deng /
  Bob Dougherty /
  Marek Grac /
  Dan Franklin /
  gary at dls.net /
  Todd A. Green /
  Donald L. Greer Jr. /
  Michelangelo Grigni /
  Zac Hansen /
  Tom Henry /
  Jarko Hietaniemi /
  Matt X. Hunter /
  Robert M. Ioffe /
  Daniel LaLiberte /
  Reuven M. Lerner /
  Trip Lilley / 
  Yannis Livassof /
  Val Luck /
  Kevin Madsen /
  David Marshall /
  James Mastros /
  Joel Meulenberg /
  Jason Moore /
  Sergey Myasnikov /
  Chris Nandor /
  Bek Oberin /
  Steve Palincsar /
  Ron Pero /
  Hans Persson /
  Sean Roehnelt /
  Jonathan Roy /
  Shabbir J. Safdar /
  Jennifer D. St Clair /
  Uwe Schneider /
  Randal L. Schwartz /
  Michael G Schwern /
  Yonat Sharon /
  Brian C. Shensky /
  Niklas Skoglund /
  Tom Snee /
  Fred Steinberg /
  Hans Stoop /
  Michael J. Suzio /
  Dennis Taylor /
  James H. Thompson /
  Shad Todd /
  Lieven Tomme /
  Lorenzo Valdettaro /
  Larry Virden /
  Andy Wardley /
  Archie Warnock /
  Chris Wesley /
  Matt Womer /
  Andrew G Wood /
  Daini Xie /
  Michaely Yeung
  
  Special thanks to:
  
  =over 2
  
  =item Jonathan Roy 
  
  for telling me how to do the C<Safe> support (I spent two years
  worrying about it, and then Jonathan pointed out that it was trivial.)
  
  =item Ranjit Bhatnagar 
  
  for demanding less verbose fragments like they have in ASP, for
  helping me figure out the Right Thing, and, especially, for talking me
  out of adding any new syntax.  These discussions resulted in the
  C<$OUT> feature.
  
  =back
  
  =head2 Bugs and Caveats
  
  C<my> variables in C<fill_in> are still susceptible to being clobbered
  by template evaluation.  They all begin with C<fi_>, so avoid those
  names in your templates.
  
  The line number information will be wrong if the template's lines are
  not terminated by C<"\n">.  You should let me know if this is a
  problem.  If you do, I will fix it.
  
  The C<$OUT> variable has a special meaning in templates, so you cannot
  use it as if it were a regular variable.
  
  There are not quite enough tests in the test suite.
  
  =cut
TEXT_TEMPLATE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#------------------------------------------------------------------------------
#
# MyRPM - Rpm Utilities
# Copyright (c) Jean-Marie RENOUARD 2014 - LightPath
# Contact : Jean-Marie Renouard <jmrenouard at gmail.com>
#
# This program is open source, licensed under the Artistic Licence v2.0.
#
# Artistic Licence 2.0
# Everyone is permitted to copy and distribute verbatim copies of
# this license document, but changing it is not allowed.
#
#------------------------------------------------------------------------------
#
#CURRENT WORK IN PROGRESSS
# ENLIGHTMENT ROAD
# FEA 0  : Using RPM::Specfile Module
# FEA 1  : Data model rewrite
# FEA 2  : Switch to Template::Magic instead of Text::Template
# FEA 4  : Include Building RPM with rpmbuild
# FEA 5  : Include init building environment steps
# FEA 6  : Adding optionnal rpmlint review
# FEA 7  : Adding repository management: create, update and fan out
# FEA 8  : Pass all corrections for perl critics
# FEA 10 : autobuild list for install
# FEA 11 : Simplify arbo big work to do  !!!
# FEA 12 : correct handling for dirAlias %{_usr} and %{_bindir}
# FEA 13 : template for user and group creation
# FEA 15 : fatten script

# VERSION 5.40
# FEA 9  : config from rpm --showrc
# FEA 3  : Include RPM Signing

# VERSION 5.41
# FEA 16 : Support requires with version indications

# VERSION 5.42
# FEA 17 : Removing Archive::Tar module (Huge memory and cpu improvments)

use warnings;
use strict;
use Text::Template;
use File::stat;
use File::Path;
use Getopt::Long;
use File::Find;
use File::Basename;
use File::Spec;
use Data::Dumper;
use RPM::Specfile;
use Cwd;
use Expect;
use Carp qw(confess);

my $version_number = "5.42";

sub AUTOLOAD {
    use vars qw($AUTOLOAD);
    my $cmd = $AUTOLOAD;
    $cmd=~s/.*:://;
    print  "\n","*" x 60, "\n* Catching system call : $cmd \n", "*"x60;
    print "\nExecution : \t", $cmd, " ",  join " ", @_;
    print "\nResult    : \t", `$cmd @_ 2>&1`;
    my $rc=$?;
    print "Code      : \t", $rc, "\n";
    return $rc;
}

# Perl trim function to remove whitespace from the start and end of the string
sub trim {
    my $string = shift;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}
printError("Wrong parameter : -N, -V ,-R at least\n$0 -h for help\n") if ( $#ARGV < 0 );

### Constant Configuration section
my @reserved_dirs = (
    '^\/bin$',    '^\/sbin$',       '^\/dev$',      '^\/home$',
    '^\/lib$',    '^\/media$',      '^\/mnt$',      '^\/proc$',
    '^\/srv$',    '^\/tmp$',        '^\/var\/log$', '^\/var\/lib$',
    '^\/var$',    '^\/boot$',       '^\/etc$',      '^\/etc\/rc.d',
    '^\/initrd$', '^\/lost+found$', '^\/root$',     '^\/selinux$',
    '^\/sys$',    '^\/usr$',        '\/usr\/sbin$', '\/usr\/bin$'
);

my @config_pattern = (
    "\.cnf", "etc",
    "initrd", "\.conf", "\.properties", "\.cnf",
    "\.ini",  "\.xml", "\.yaml", "\.json"
);
my @doc_pattern =
  ( "doc", "\.txt", "README", "LICENCE", "LICENSE",
  "TODO", "\.html", "\.tex", "\.txt", "\.pdf" );

my %dirAlias = (
    "/usr/lib64"     => "%{_libdir}",
    "/usr/sbin"    => "%{_sbindir}",
    "/usr/bin"     => "%{_bindir}",
    "/usr/libexec" => "%{_libexecdir}",
    "/usr/share"   => "%{_datadir}",
    "/var"         => "%{_var}",

    #New problem to avoid
    #	"/usr"	       => "%{_usr}",
    # "/usr/lib"     => "%{_libdir}",
);

my $topdir          = getParameterFromConfig( "_topdir" );
my $specDir         = $topdir . "/SPECS";
my $srcDir          = $topdir . "/SOURCES";
my $srpmDir          = $topdir . "/SRPMS";
my $archiveRootPath = "/tmp/myrpm";

### Misc declaration section
# Var to store each line
my $line = q();
my @other_arg=();
# File list
my @files     = ();
my @instFiles = ();
my @instDirs  = ();

my @defFiles     = ();
my @defConfFiles = ();
my @defDocFiles  = ();

### Command line option section
Getopt::Long::Configure('bundling');

my (
    $help,          $build,           $verbose,     $multi,
    $templateName,  $root_dir,        $snap_dir,    $Name,
    $Version,       $Release,         $Description, $Summary,
    $ChangeLog,     $Packager,        $Vendor,      $VendorUrl,
    $Archi,         $Distro,          $archive,     $requires_string,
    $pre_script,    $build_script,    $post_script, $preun_script,
    $postun_script, $exclude_pattern, $uid,         $gid,
    $nodoc,         $noconf,          $nores,       $optimize,
    $nostrip,       $signRpm,         $sign,        $password
);

GetOptions(
    "h|help"             => \$help,
    "b|build"            => \$build,
    "v|verbose"          => \$verbose,
    "m|multiple"         => \$multi,
    "t|template=s"       => \$templateName,
    "r|root-directory=s" => \$root_dir,
    "d|directory=s"      => \$snap_dir,
    "x|exclude=s"        => \$exclude_pattern,
    "a|archive=s"        => \$archive,
    "u|uid=s"            => \$uid,
    "g|gid=s"            => \$gid,
    "n|nodoc"            => \$nodoc,
    "i|nostrip"          => \$nostrip,
    "c|noconfig"         => \$noconf,
    "s|noreserved"       => \$nores,
    "o|optimize"         => \$optimize,
    "N|name=s"           => \$Name,
    "V|version=s"        => \$Version,
    "R|release=s"        => \$Release,
    "C|changelog=s"      => \$ChangeLog,
    "D|description=s"    => \$Description,
    "S|summary=s"        => \$Summary,
    "P|packager=s"       => \$Packager,
    "O|vendor=s"         => \$Vendor,
    "U|url-vendor=s"     => \$VendorUrl,
    "A|architecture=s"   => \$Archi,
    "T|distribution=s"   => \$Distro,
    "signRpm"            => \$signRpm,
    "sign"               => \$sign,
    "password=s"         => \$password,
    "requires=s"         => \$requires_string,
    "pre-script=s"       => \$pre_script,
    "post-script=s"      => \$post_script,
    "preun-script=s"     => \$preun_script,
    "postun-script=s"    => \$postun_script,
    "build-script=s"     => \$build_script,
    '<>'                 => \&add_args
);

sub add_args {
    push @other_arg, @_;
}

printUsage($0) if defined $help;

($templateName) || ( $templateName = shift ) || ( $templateName = q() );
    ($root_dir)     || ( $root_dir     = shift ) || ( $root_dir     = q() );
$root_dir =~ s/\/$//;

($snap_dir) || ( $snap_dir = shift ) || ( $snap_dir = q() );
    $snap_dir =~ s/\/$//;

($exclude_pattern)
  || ( $exclude_pattern = shift )
  || ( $exclude_pattern = q() );

($archive) || ( $archive = shift ) || ( $archive = undef );

($uid) || ( $uid = shift ) || ( $uid = 0 );
($gid) || ( $gid = shift ) || ( $gid = 0 );

($ChangeLog)
  || ( $ChangeLog = shift )
  || ( $ChangeLog = "http://www.jmrenouard.fr - RPM solution provider" );

($Packager)
  || ( $Packager = shift )
  || ( $Packager =
    getParameterFromConfig( "packager" ) );
($Vendor)
  || ( $Vendor = shift )
  || ( $Vendor = getParameterFromConfig( "vendor" ) );
($VendorUrl)
  || ( $VendorUrl = shift )
  || ( $VendorUrl =
    getParameterFromConfig( "vendor_url" ) );
($Archi)
  || ( $Archi = shift )
  || ( $Archi = getParameterFromConfig( "_arch", "noarch" ) );

my $rpmDir          = $topdir . "/RPMS/".$Archi;

($Distro)
  || ( $Distro = shift )
  || ( $Distro = getParameterFromConfig( "_dist" ) );

($pre_script) || ( $pre_script = shift ) || ( $pre_script = q() );
print "\n * pre : $pre_script" if defined $verbose;

($preun_script) || ( $preun_script = shift ) || ( $preun_script = q() );
print "\n * preun : $preun_script" if defined $verbose;

($post_script) || ( $post_script = shift ) || ( $post_script = q() );
print "\n * post : $post_script" if defined $verbose;

($postun_script) || ( $postun_script = shift ) || ( $postun_script = q() );
print "\n * postun : $postun_script" if defined $verbose;

($build_script) || ( $build_script = shift ) || ( $build_script = q() );
print "\n * install : $build_script" if defined $verbose;

($requires_string)
  || ( $requires_string = shift )
  || ( $requires_string = q() );
print "\n * requires info : $requires_string" if defined $verbose;

my @reqs = split( q/,/, $requires_string );
s/>=(\d)/ >= $1/g for (@reqs);
s/<=(\d)/ <= $1/g for (@reqs);
s/=(\d)/ = $1/g for (@reqs);
@doc_pattern    = () if defined $nodoc;
@config_pattern = () if defined $noconf;
@reserved_dirs  = () if defined $nores;

### Checking arguments section
print "\t * Version : " . $version_number . "\n" if defined $verbose;

my %lusers;
my %lgroups;


### Signing mode detection
if (defined $signRpm and scalar(@other_arg) > 0) {
    unless ( defined ($password)) {
      printError("Missing password for signing rpms....");
    }
    my $nb=0;
    foreach my $rpm (grep { /\.rpm/ } @other_arg) {
       rpmSign($password, [ $rpm ] );
       $nb++;
    }
    exit 0 if ($nb == scalar @other_arg);
}
($Name) || ( $Name = shift ) || ( printError("Missing -N option : mandatory") );
($Version)
  || ( $Version = shift )
  || ( printError("Missing -V option : mandatory") );
($Release)
  || ( $Release = shift )
  || ( printError("Missing -R option : mandatory") );
### Version : $Version
printError("Wrong version format : XX.YY;ZZ, XX.YY, ...")
  unless ( $Version =~ /^[0-9][0-9\.]*$/ );
print "Checking version : $Version: OK\n" if defined $verbose;

### Release : $Release
printError("Wrong release format : X without dots")
  unless ( $Release =~ /^[1-9][0-9]*$/ );
print "Checking release : $Release: OK\n" if defined $verbose;
($Description)
  || ( $Description = shift )
  || ( $Description = "Package $Name-$Version-$Release" );
($Summary)
  || ( $Summary = shift )
  || ( $Summary = "This package is used for $Name-$Version-$Release" );


### Archive mode detection
### Archive file : $archive
my $tmp_dir = undef;
if ( defined $archive ) {
    ### Archive handling section
    # check archive permissions
    printError("Unable to read archive file $archive") unless -r $archive;

    # Create temporary dir
    $snap_dir = "$archiveRootPath/$$";
    $tmp_dir  = "$snap_dir/$root_dir";
    print "\n * Try to create $tmp_dir" if defined $verbose;
    eval { mkpath($tmp_dir) };
    if ($@) {
        print "\n * Couldn't create $tmp_dir: $@";
    }
    print "\n* $tmp_dir created." if defined $verbose;
    my $cwdir = getcwd;
    chdir $tmp_dir;

    my $compressed_archive = ( $archive =~ /.+?\.(?:tar\.gz|tgz)$/i );
    #my $arch_obj = Archive::Tar->new( $archive, $compressed_archive );
    #$arch_obj->extract();
    if ($compressed_archive ) {
        tar ("xzf", $archive);
    } else {
        tar ("xf", $archive);
    }

    #change uid if necessary
    print "\n* $uid($gid) rigths setting." if defined $verbose;
    $uid = getUserId($uid);
    $gid = getGroupId($gid);
    find(
        sub {
            print "\n * setting rigths for $_" if defined $verbose;
            chown $uid, $gid, $_;
        },
        $tmp_dir
    );
    chdir $cwdir;

    #Priority for archive option
    $root_dir = $snap_dir;
}

###Checking directories section
my $current_dir = getcwd;
### Cwd: $current_dir
$root_dir = trim $current_dir if ( $root_dir =~ /^\.$/ );

### Root Dir: $root_dir
print "Root directory : ==>$root_dir<==\n" if defined $verbose;
printError("Root dir doesnt exists or is empty")
  unless ( -d $root_dir || $root_dir eq q() );
print "Checking root_dir OK\n" if defined $verbose;

$snap_dir = trim $current_dir if ( $snap_dir =~ /^\.$/ );
### Snap dir : $snap_dir
print "Snap directory : ==>$snap_dir<==\n" if defined $verbose;
printError("Snapshot dir doesn t exist or is empty")
  unless ( -d $snap_dir || $snap_dir eq q() );
print "Checking snap_dir OK\n" if defined $verbose;

my @inputFileList = getInputFileLine($snap_dir);

### Pattern exclusion section
my @exclude_patterns = ();
@exclude_patterns = split q/,/ , $exclude_pattern
  if ( $exclude_pattern ne q() );

### Exclude patterns : @exclude_patterns
my %user_infos  = getUserMap();
my %group_infos = getGroupMap();

my %used_users     = ();
my %used_groups    = ();
my %symbolic_links = ();

### Start handling file list
foreach (@inputFileList) {    ### Evaluating [===|    ] % done
                              #sleep 2;
    my $line = $_;

    # Removing empty line
    next if ( $line eq q() );

    printError("Unable to read item : $line") unless -r $line || -l $line;

        #Translation of all line starting by a ./something into a absolute path
### Original File : $line
    $line = File::Spec->rel2abs($line);
### Absolute File : $line

    #The root dir is excluded
    next if ( $line eq $root_dir );

    my $pattern_found = 0;
    foreach (@exclude_patterns) {
        if ( $line =~ /$_/ ) {
            $pattern_found = 1;
            print "* Pattern found : $pattern_found for $line\n\n "
              if defined $verbose;
            last;
        }
    }

    next if ( $pattern_found == 1 );
    my $line_chrooted = $line;

    # Removing root_dir entry
    next if ( $line_chrooted eq $root_dir );

### $line is not excluded
    $line_chrooted =~ s/^$root_dir\///;
    print "OK for $line_chrooted" if defined $verbose;

    print "\n* Traitement de '$line'" if defined $verbose;
### Chrooted line : $line_chrooted
    #Symbolic link handling
    if ( -l $line ) {
        ### $line is symbolic link
        my $lnkName=readlink($line);

        my $pointedItem = File::Spec->rel2abs( $lnkName );
	$pointedItem =~ s/^$root_dir\///;

	#fix for . link
	$pointedItem=$lnkName if ( $lnkName eq "." or $lnkName eq "./" );

        ### LINK: /$line_chrooted
	### DEST: $pointedItem

        $symbolic_links{ "/" . $line_chrooted } = $pointedItem;
        next;
    }
    confess(" $line does nt exists") unless ( -e $line );

    my $statFile = stat($line);
    my $mode     = $statFile->mode;
    my $uid      = $statFile->uid;
    my $gid      = $statFile->gid;

    print "\n* UID $uid GID : $gid" if defined $verbose;
    $used_users{$uid}++;
    $used_groups{$gid}++;
    confess ("$line without uid") unless defined $uid;
    confess ("$line without gid") unless defined $gid;

    print "\n * USED USERS :",  join ',', keys %used_users  if defined $verbose;
    print "\n * USED GROUPS :", join ',', keys %used_groups if defined $verbose;

    confess ("$line without valid uid name") unless defined $user_infos{$uid}{'name'};
    confess ("$line without valid gid name") unless defined $group_infos{$gid}{'name'};

    print "\n* user=", $user_infos{$uid}{'name'}   if defined $verbose;
    print "\n* group=", $group_infos{$gid}{'name'} if defined $verbose;

    my $trueMode = sprintf( "%04o", $mode & 07777 );
    push @files, "./$line_chrooted";
    print "\n\t * $line into Tar ball....\n" if defined $verbose;
    print "\t * $line and $line_chrooted into Spec file....\n"
      if defined $verbose;

    my $final_path = substituteAliasDir("/$line_chrooted");

    my %tmpData = ();
    $tmpData{mode}   = $trueMode;
    $tmpData{r_file}   = $line_chrooted;
    $tmpData{d_file}   = escapeDollarChars($line_chrooted);
    #print "\n~~~~~~~~~~~~~ $line_chrooted";
    $tmpData{file}   = escapeParChars($line_chrooted);
    $tmpData{r_path}   = $final_path;
    $tmpData{se_path}   = escapeSpaceChars($final_path);
    $tmpData{Se_path}   = escapeParChars($final_path);
    $tmpData{sSe_path}   = escapeSpaceChars (escapeParChars($final_path));
    $tmpData{psd_path}   = escapeDollarChars (escapeSpaceChars (escapeParChars($final_path)));
    $tmpData{pd_path}   = escapeDollarChars (escapeSpaceChars (escapeParChars($final_path)));
  #  $tmpData{r_path} = $final_path;
    $tmpData{uid}    = $user_infos{$uid}{'name'};
    $tmpData{gid}    = $group_infos{$gid}{'name'};

    #File case
    if ( -f "$line" ) {
        push @instFiles, \%tmpData;

        my $isDoc    = isDocFile("/$line_chrooted");
        my $isConfig = isConfigFile("/$line_chrooted");

        # Fix bug if is config and is doc at the same time
        #Choice to be a config file
        $isDoc = 0 if ( $isDoc && $isConfig );

        push @defFiles, \%tmpData if ( !$isDoc && !$isConfig );
        push @defConfFiles, \%tmpData if ($isConfig);
        push @defDocFiles,  \%tmpData if ($isDoc);
    }

    # Directory case
    # Must not be a reserved directory
    if ( -d "$line" ) {
        $tmpData{comment} = 1 if isReservedDir("/$line_chrooted");
        $tmpData{isDir} = 1;
        push @instDirs, \%tmpData;

        push @defFiles, \%tmpData if ( !isReservedDir("/$line_chrooted") );
    }
}    ### -End handling file list

### Summary First $snap_dir Analyse
### Installation File List : @instFiles
### Installation Dir  List : @instDirs
### Definition File List : @defFiles
### Definition Configuration file List : @defConfFiles
### Definition Documentation file List : @defDocFiles

# Heuristic arbo simplification
my @rootDirs = ();
if ( defined $optimize ) {
    ### Optimisation activated
    foreach my $dirItem (@instDirs) {
        my $parentDir = dirname( $$dirItem{file} );

        push @rootDirs, $dirItem if ( $parentDir eq "." );
        @{ $$dirItem{subFolder} } = ();
        foreach my $subFolder (@instDirs) {
            push @{ $$dirItem{subFolder} }, $subFolder
              if dirname( $$subFolder{file} ) eq $$dirItem{file};
        }

        @{ $$dirItem{subFiles} } = ();
        foreach my $subFile (@defFiles) {
            push @{ $$dirItem{subFiles} }, $subFile
              if !defined $$subFile{isDir}
                  and dirname( $$subFile{file} ) eq $$dirItem{file};
        }

        @{ $$dirItem{subConf} } = ();
        foreach my $subFile (@defConfFiles) {
            push @{ $$dirItem{subConf} }, $subFile
              if dirname( $$subFile{file} ) eq $$dirItem{file};
        }

        @{ $$dirItem{subDoc} } = ();
        foreach my $subFile (@defDocFiles) {
            push @{ $$dirItem{subDoc} }, $subFile
              if dirname( $$subFile{file} ) eq $$dirItem{file};
        }
    }
}

#exit 0 ;

print "\n * uniq uids :" . join ', ', keys %used_users  if defined $verbose;
print "\n * uniq gids :" . join ', ', keys %used_groups if defined $verbose;

#Handling group creation
my @group_creation = ();
foreach ( keys %used_groups ) {

    #Avoid root group creation
    next if ( $_ == 0 );
    push @group_creation, $group_infos{$_};
}

#Handling user creation
my @user_creation = ();
foreach ( keys %used_users ) {

    #avoid root account :)
    #Avoid root user creation
    next if ( $_ == 0 );
    next if ( $_ < 500 );
    next if ( $user_infos{$_}{'shell'} =~ /nologin/ );
    print "\n*" . $user_infos{$_}{'name'} . " in users $_" if defined $verbose;

    # For all non system account
    # password is the same than user name
    # WARNING : Security issues around this feature
    $user_infos{$_}{init} = 1;
    push @user_creation, $user_infos{$_};
}

if ( defined $optimize ) {
    simplifyIt( \@rootDirs, \@defFiles, \@defDocFiles, \@defConfFiles,
        \@instFiles );
### Summary First $snap_dir Analyse
### Installation File List : @instFiles
### Installation Dir  List : @instDirs
### Definition File List : @defFiles
### Definition Configuration file List : @defConfFiles
### Definition Documentation file List : @defDocFiles
### Definition Documentation file List : @defDocFiles
### Definition Root Dirs List : @rootDirs
}

# if a instDir contains only doc or config or file with same user and unix rigths then a * can substitute all included files and directory ( * is ok for file )
#Even if it is in comment
# The process must call the same fonction on its subdirectories first
# About the recursion of the process


my $pre_code = getScriptFileContent($pre_script);

#Handling symbolic link replacement as post install code
my $post_code = getScriptFileContent($post_script);

my $templDef = getSpecTemplate($templateName);

my $template = Text::Template->new(
    SOURCE     => "$templDef",
    TYPE       => 'STRING',
    DELIMITERS => [ "<", ">" ]
) or confess "Couldn't construct template: $Text::Template::ERROR";

my %vars = (
    name              => "$Name",
    version           => "$Version",
    release           => "$Release",
    summary           => "$Summary",
    description       => "$Description",
    reqs              => \@reqs,
    packager          => "$Packager",
    vendor            => "$Vendor",
    vendor_url        => "$VendorUrl",
    archi             => "$Archi",
    distro            => "$Distro",
    multiple_packages => defined $multi,
    users             => \@user_creation,
    groups            => \@group_creation,
    nostrip	      => $nostrip,
    #Pre_code must be list
    pre_code => "$pre_code",

    #Post_code must be list
    post_code => "$post_code",

    symbolic_links => \%symbolic_links,
    preun_code     => getScriptFileContent($preun_script),

    postun_code => getScriptFileContent($postun_script),

    build_code => getScriptFileContent($build_script),

    # must be information only
    listOfFiles => \@defFiles,

    # must be information only
    listOfDocFiles => \@defDocFiles,

	# must be information only
    listOfConfFiles => \@defConfFiles,

    instFiles => \@instFiles,
    instDirs  => \@instDirs,

    ChangeLog => $ChangeLog,

    # must be information only
    OldChangeLogs => getChangeLogs("$specDir/$Name.spec"),

    #Avoid system call for portability
    date => trim(`unset LANG && date +"%a %b %d %Y"`)
);

my $result = $template->fill_in( HASH => \%vars );

confess "Couldn't fill in template: $Text::Template::ERROR"
  unless ( defined $result );

# Chrrooting in fact
if   ( $root_dir eq q() ) { chdir("/") }
else                      { chdir($root_dir); }

#generate Tarball
my $tarFilename="$srcDir/$vars{'name'}-$vars{'version'}.tar.gz";
foreach my $file (@files) {
    $file =~ s/^\//\.\//;
    if (-f "$tarFilename") {
        tar ("czf", $tarFilename, $file);
    } else {
        tar ("rzf", $tarFilename, $file);
    }
}

#Writing spec file
open my $fh, q(>), "$specDir/$vars{'name'}.spec"
  or printError(
"Unable to open $specDir/$vars{'name'}.spec in write mode. please check permissions for this file or directory"
  );
print $fh $result if defined($result);
print $result if ( defined($result) && $verbose );
close $fh;

# Cleaning archive tmp dir
if ( defined $archive ) {

    # Create temporary dir
    my $tmp_dir = "/tmp/myrpm/$$";
    eval { rmtree($tmp_dir) };
    if ($@) {
        print "Couldn't create $tmp_dir: $@";
    }
}

print "\n#Executing to build package : rpmbuild\n" if ($verbose);
rpmbuild (
    '--quiet',
    '-ba',
    "--target=$Archi",
    "$specDir/$vars{'name'}.spec",
    defined($verbose)?"1>/dev/null 2>&1":""
    ) if($build);


print "\n#Signing package : rpm --addSign\n" if ($verbose);
rpmSign ($password, [ "$srpmDir/$vars{'name'}.src.rpm", "$rpmDir/$vars{'name'}.$Archi.rpm" ]) if ($sign and $password);

exit 0;

sub printUsage {
    my $s = shift;
    perldoc ( $s );
    exit 0;
}

sub printError {
    my @content = @_;
    my $message = join( ' ', @content );
    print STDERR $message;

    exit 1;
}

sub escapeParChars {
    my $line = shift;
    $line =~ s/(\()/\\$1/g;
    $line =~ s/(\))/\\$1/g;
    $line =~ s/(\])/\\$1/g;
    $line =~ s/(\[)/\\$1/g;

    # since a bug with \\
    #$line=~s/(\&))/\\$1/g;
    #$line=~s/(\\)/\\\\/g;
    return $line;
}

sub escapeSpaceChars{
    my $line = shift;
    $line =~ s/(\ )/\\$1/g;
    return $line
}

sub escapeDollarChars{
    my $line = shift;
    $line =~ s/(\$)/\\$1/g;
    return $line
}

sub isReservedDir {
    my $dir = shift;
    print "\n* Testing $dir as reserved" if defined $verbose;
    foreach my $rdir (@reserved_dirs) {
        return 1 if ( $dir =~ /$rdir/i );
    }
    print "\n* $dir is NOT reserved" if defined $verbose;
    return 0;
}

sub isDocFile {
    my $file = shift;
    print "\n* Testing $file as doc" if defined $verbose;
 	foreach my $dpat (@doc_pattern) {
        print ($file =~ /$dpat/);
		return 1 if ( $file =~ /$dpat/ );
    }
    print "\n* $file is NOT doc" if defined $verbose;
    #exit 0;
	return 0;
}

sub isConfigFile {
    my $file = shift;
    print "\n* Testing $file as config" if defined $verbose;
    foreach my $cpat (@config_pattern) {
        return 1 if ( $file =~ /$cpat/ );
    }
    print "\n* $file is NOT config" if defined $verbose;
    return 0;
}

sub substituteAliasDir {
    my $path = shift;

    #my $not_found=1;
    foreach my $subpath ( sort keys %dirAlias ) {

        #break unless ($not_found);
        print "$subpath lookup\n" if defined $verbose;
        if ( $path =~ /^$subpath/ ) {
            my $alias = $dirAlias{$subpath};
            print "=> $subpath FOUND : substitute by : $alias\n"
              if defined $verbose;
            $path =~ s/^$subpath/$alias/;
            print "* Substitution is :" . $path . "\n" if defined $verbose;
            return $path;
        }
    }
    return $path;
}

sub getChangeLogs {
    my $specFile = shift;
    return q() unless ( -f $specFile );
    print "$specFile found...." if defined $verbose;
    my @lines                = getFileContents($specFile);
    my @changeLogs           = ();
    my $changeLogHeaderFound = 0;
    foreach (@lines) {
        push @changeLogs, $_ if $changeLogHeaderFound == 1;
        $changeLogHeaderFound = 1 if /^%changelog/;
    }
    return join( q(), @changeLogs );
}

sub getScriptFileContent {
    my $filename = shift;
    return q() if $filename eq q();
    return q() unless -f $filename;
    my @lines = getFileContents($filename);

    # remove first line
    my $interp;
    if ( defined( $lines[0] ) && $lines[0] =~ /^#!/ ) {

        #$lines[0] =~ s/#!(.*)/$1 << SCRIPT_END/;
        $lines[0] = q();

        #push @lines, "SCRIPT_END";
    }

    return join q(), @lines;
}

sub rpmSign {
    my $password=shift;
    my @rpmFiles=@_;

    my $timeout=60;
            my $command="rpm --addsign ". join " ", @rpmFiles;

        print " => $command\n";

        my $exp = Expect->spawn($command) or die "Cannot spawn $command: $!\n";
        $exp->raw_pty(1);
        SAISIE:
        $exp->expect($timeout,
            [ '.+ passe:' => sub {
                    $exp->send("$password\n");
                    goto SAISIE;
                }
            ],
            [ '.+ passphare:' => sub {
                    $exp->send("$password\n");
                    goto SAISIE;
                }
            ],
            [ '.+\r\n$' => sub {
                    goto SAISIE; } ],
        );
        $exp->soft_close();
}

sub getFileContents {
    my $filename = shift;
    print "* reading $filename " if defined $verbose;
    my $fh;
    open( $fh, q(<), "$filename" )
      or confess "Couldn't open $filename for reading: $!\n";
    my @lines = <$fh>;

    close($fh);
    return @lines;
}

sub getUserMap {
    my $file         = "/etc/passwd";
    my %localUserMap = ();
    my $fh;
    open( $fh, q(<), $file ) or confess "$file : $!";

    while (<$fh>) {
	chomp($_);
        ### Line : $_
        my ( $user, $passwd, $uid, $gid, $desc, $home, $shell ) =
          split qw/:/, $_;
        next unless defined $user;
        $desc = 'default comment' if ( $desc eq q() );
        $localUserMap{$uid}{'name'}    = $user;
        $localUserMap{$uid}{'gid'}     = $gid;
        $localUserMap{$uid}{'uid'}     = $uid;
        $localUserMap{$uid}{'comment'} = $desc;
        $localUserMap{$uid}{'shell'}   = $shell;
        $localUserMap{$uid}{'home'}    = $home;
    }

    close($fh);
    ### user Map : %localUserMap
    return %localUserMap;
}

sub getUserId {
    my $search_name  = shift;
    my $file         = "/etc/passwd";
    my %localUserMap = ();
    my $fh;
    open( $fh, q(<), "$file" ) or confess "$file : $!";

    while (<$fh>) {
        chomp($_);
        my ( $user, $passwd, $uid, $gid, $desc, $home, $shell ) =
          split qw/:/;
        next unless defined $user;
        return $uid if ( $user eq $search_name );
        return $uid if ( $uid  eq $search_name );
    }

    close($fh);
    return 0;
}

sub getGroupMap {
    my $file          = "/etc/group";
    my %localGroupMap = ();
    my $fh;
    open( $fh, q(<), $file ) or confess "$file : $!";

    while (<$fh>) {
        chomp($_);
        my ( $group, $passwd, $gid, $members ) = split qw/:/;
        $localGroupMap{$gid}{'gid'}     = $gid;
        $localGroupMap{$gid}{'name'}    = $group;
        $localGroupMap{$gid}{'members'} = $members;
    }
    close($fh);
    ### Group Map : %localGroupMap
    return %localGroupMap;
}

sub getGroupId {
    my $search_group = shift;
    my $file         = "/etc/group";
    my $fh;
    open( $fh, q(<), "$file" ) or confess "$file : $!";
    my %localGroupMap = ();
    my $res           = undef;
    while ( not defined($res) and <$fh> ) {
        chomp($_);
        my ( $group, $password, $gid, $members ) = split qw/:/;
        $res = $gid if ( $group eq $search_group or $gid eq $search_group );
    }
    close $fh;
    return $res;
}

sub getUniqElement {
    my %seen = ();
    return grep { !$seen{$_}++ } shift;
}

sub getInputFileLine {
    my $directory = shift;
    print "==>$directory<== ....\n" if defined($verbose);
    my @result = ();
    my $line   = q();
    if ( defined($directory) && ( -d $directory ) ) {
        print "$directory exists....\n" if defined($verbose);

        find sub {
            my $line = $File::Find::name;
            $line .= "/" if -d;

            #print "=> $line\n" if defined($verbose);
            push @result, $line;
        }, ($directory);
    }
    else {
        print "==>INPUT FILE LIST<== ....\n" if defined($verbose);

        while ( defined( $line = <> ) ) {
            $line = trim($line);

            #print "=> $line\n" if defined($verbose);
            push @result, $line;
        }
    }
    print "\n" if defined $verbose;
    return @result;
}


sub getParameterFromConfig {
   my ($parameter, $default) = @_;

   $default="" unless defined $default;
   foreach my $param (`rpm --showrc | grep "\\-14\\:"`) {
        if ($param =~ /\s$parameter\s(.*)$/) {
            return $1;
        }
   }

   return $default;
}

sub simplifyIt {
    my $rootDirs     = shift;
    my $defFiles     = shift;
    my $defDocFiles  = shift;
    my $defConfFiles = shift;
    my $instFiles    = shift;
    return if scalar @{$rootDirs} == 0;
    foreach my $ldir ( @{$rootDirs} ) {
        my $nbChildNode = scalar( @{ $$ldir{subFolder} } );
        print "\t\t nb Child folder : $nbChildNode" if $verbose;
        unless ( $nbChildNode == 0 ) {
            simplifyIt( $$ldir{subFolder}, $defFiles, $defDocFiles,
                $defConfFiles, $instFiles );
        }
        else {
            simplifyOneDir( $ldir, $defFiles, $defDocFiles, $defConfFiles,
                $instFiles );
        }
    }
    return 0;
}

sub simplifyOneDir {
    my $folder       = shift;
    my $defFiles     = shift;
    my $defDocFiles  = shift;
    my $defConfFiles = shift;
    my $instFiles    = shift;

    my $refFiles  = undef;
    my $itemLabel = undef;
    if (    scalar( @{ $$folder{subFiles} } ) > 0
        and scalar( @{ $$folder{subDoc} } ) == 0
        and scalar( @{ $$folder{subConf} } ) == 0 )
    {
        $refFiles  = $defFiles;
        $itemLabel = 'subFiles';
    }
    if (    scalar( @{ $$folder{subFiles} } ) == 0
        and scalar( @{ $$folder{subDoc} } ) > 0
        and scalar( @{ $$folder{subConf} } ) == 0 )
    {
        $refFiles  = $defDocFiles;
        $itemLabel = 'subDoc';
    }
    if (    scalar( @{ $$folder{subFiles} } ) == 0
        and scalar( @{ $$folder{subDoc} } ) == 0
        and scalar( @{ $$folder{subConf} } ) > 0 )
    {
        $refFiles  = $defConfFiles;
        $itemLabel = 'subConf';
    }

    return unless defined($refFiles);

    # Simplify Files section
    my $firstFile = undef;

    #my $isSimple=0;
    my $isSimple = 1;
    foreach my $file ( @{ $$folder{$itemLabel} } ) {
        $firstFile = $file unless defined($firstFile);

     #$isSimple=1 if $file != $firstFile and checkFilesForm( $file, $firstFile);
        $isSimple = 0 unless checkFilesForm( $file, $firstFile );
    }
    print "x" x 40 if $verbose;
    if ($isSimple) {

        #Here IS THE BIG WORK :)
        # remove all
        foreach my $file ( @{ $$folder{$itemLabel} } ) {
            removeFromArray( $refFiles,  $file ) unless $file == $firstFile;
            removeFromArray( $instFiles, $file ) unless $file == $firstFile;
        }
        $$firstFile{r_path} = $$folder{r_path} . "/*";
        $$firstFile{path}   = $$folder{path};
        $$firstFile{file}   = $$folder{file} . "/*";
    }
    return 0;
}

sub removeFromArray {
    my $arr = shift;
    my $elt = shift;
    my $i   = 0;
    foreach my $item ( @{$arr} ) {
        next unless defined $item;
        last if ( $item == $elt );
        $i++;
    }
    @{$arr} = @{$arr}[ 1 .. scalar( @{$arr} ) - 1 ] if ( $i == 0 );
    @{$arr} = @{$arr}[ 0 .. scalar( @{$arr} ) - 2 ]
      if ( $i == scalar( @{$arr} ) - 1 );
    @{$arr} = @{$arr}[ 0 .. $i - 1, $i + 1 .. scalar( @{$arr} ) - 1 ]
      if $i < scalar( @{$arr} );

    return 0;
}

sub checkFilesForm {
    my $f1 = shift;
    my $f2 = shift;

    return 1 if $f1 == $f2;
    return 1
      if $$f1{uid} eq $$f2{uid}
          and $$f1{mode} eq $$f2{mode}
          and $$f1{gid}  eq $$f2{gid};
    return 0;
}

sub getSpecTemplate {

    # THE TEMPLATE
    my $defaultSpecTemplate = << 'EOF';
Summary: 		<$summary>
Name:			<$name>
Version: 		<$version>
Release:	   	<$release>
License: 		GPL
URL: 			<$vendor_url>
Source0: 		%{name}-%{version}.tar.gz
Group: 			System/Administration
Vendor:			<$vendor>
Packager:		<$packager>
#Archi: 			<$archi>
<if (@reqs == 0 ) {$OUT.="AutoReqProv: 		no"; } >
BuildRoot: 		%{_tmppath}/%{name}-%{version}-root
< foreach $req (@reqs) { $OUT.= "Requires: $req\n"; }>
%description
<$description>

< if (@listOfConfFiles != 0) {
    $OUT.="%package config
Summary: Configuration for $name
Group: System/Administration

%description config
Configuration files for $name
$description";
	} >
<if (@listOfDocFiles != 0) {
	$OUT.="%package doc
Summary: Documentation for $name
Group: System/Administration

%description doc
Documentation files for $name
$description";
} >

%prep
#%setup -q
#-n %{name}-%{version}
%setup -c -q
< if ($nostrip) { $OUT.="%define __strip /bin/true
%define debug_package %{nil}"; }>
%build
<$build_code>
%install
rm -Rf %{buildroot}
mkdir -p %{buildroot}/usr/lib/debug

#Directory installation
< foreach $i (@instDirs) {
    $comment=$$i{comment};
    $file=$$i{r_file};
    $mode=$$i{mode};
    $path=$$i{r_path};
#	$OUT.= "#Uncomment if needed - consider as a reserved dir\n#" if ($comment);
    $OUT.="%{__install} -d -m $mode \"$file\" \"%{buildroot}$path\"\n";

	}>
#Files installation
< foreach $i (@instFiles) {
	$file=$$i{d_file};
	$mode=$$i{mode};
	$path=$$i{psd_path};
	$pdpath=$$i{pd_path};
        $OUT.= "[ -d \"`dirname %{buildroot}$path`\" ] || %{__mkdir_p} \"`dirname %{buildroot}$pdpath`\"\n";
	$OUT.= "%{__install} -m $mode \"$file\" \"%{buildroot}/$file\"\n";
    }>
%pre
<  if (@groups == 0 ) {
	    $OUT.="# No group Creation";
	} else {
	    $OUT.="# Group creation";
	    foreach $i (@groups){
		$gid=$$i{gid};
		$gname=$$i{name};
		$OUT.="\nif egrep -q \"$gname\" /etc/group; then";
		$OUT.="\n\techo \"#Group $gname already exists !\"";
		$OUT.="\nelse";
		$OUT.="\n\tgroupadd -g $gid $gname";
		$OUT.="\nfi";
	    }
	}
   if (@users == 0 ) {
		$OUT.="\n# No User Creation";
    } else {
	$OUT.="\n# User creation";
	foreach $i (@users) {
	    $uname=$$i{name};
	    $gid=$$i{gid};
	    $shell=$$i{shell};
	    $home=$$i{home};
	    $comment=$$i{comment};
	    $uid=$$i{uid};
	    $is_init=$$i{init};
	    $OUT.="\nif egrep -q \"$uname\" /etc/passwd; then";
	    $OUT.="\n\techo \"User $uname already exists !\"";
	    $OUT.="\nelse";
	    $OUT.="\n\tadduser -u $uid -g $gid -s $shell -d $home -c \"$comment\" $uname && USER_NEW=1 || true";
	    $OUT.="\n\t# Changing password for non priviliged user";
	    $OUT.="\n\techo $uname | passwd --stdin $uname";
	    $OUT.="\nfi";
	}
   }>

< $OUT.="\n$pre_code";>

%post< foreach $i (keys %symbolic_links) {
	    $link=$i;
	    $pointee=$symbolic_links{$i};
	    $OUT.="\n#Symbolic link $i - $pointee";
	    $OUT.="\ncd `dirname $i`";
	    $OUT.="\nrm -fv `basename $i`";
	    $OUT.="\nln -fvs $pointee `basename $i`";
	    $OUT.="\ncd -";
	}>
<$post_code>
%preun
<$preun_code>
%postun
<$postun_code>
%clean
rm -Rf %{buildroot}

#Regular file and dir list
%files
< foreach $i (@listOfFiles) {
	    $mode=$$i{mode};
	    $path=$$i{r_path};
	    $comment=$$i{comment};
	    $uid=$$i{uid};
	    $gid=$$i{gid};
	    $OUT.="#Uncomment if needed !\n#" if (defined $comment);
	    $OUT.="%attr($mode $uid, $gid) ";
	    $OUT.="%dir " if ($$i{isDir});
	    $OUT.="\"$path\"\n";}>
< if ( @listOfConfFiles != 0 ) { $OUT.="#Configuration file list"; }>
< if ( @listOfConfFiles != 0 ) { $OUT.= "%files config"; }>
< foreach $i (@listOfConfFiles) { $OUT.="%attr($$i{mode} $$i{uid}, $$i{gid}) %config \"$$i{Se_path}\"\n"; }>
< if ( @listOfDocFiles != 0 ) {
		$OUT.= "#Documentation file list\n";
		$OUT.= "%files doc\n";
}>< foreach $i (@listOfDocFiles) { $OUT.= "%attr($$i{mode} $$i{uid}, $$i{gid}) %doc \"$$i{Se_path}\"\n"; }>
%changelog
* <$date> <$packager> <$name>-<$version>-<$release>
- <$ChangeLog>
-  Generated version.

<$OldChangeLogs>
EOF

    my $fileName = shift;
    my $res      = $defaultSpecTemplate;
    if ( $fileName ne q() ) {
        print "\n* Alternate spec skeleton filename : $fileName\n"
          if defined $verbose;

        my $opened = 1;
        my $fh;
        open( $fh, q(<), "$fileName" ) || ( $opened = 0 );

        if ($opened) {
            $res = q();
            while (<$fh>) {
                $res .= $_;
            }
            close($fh);
        }
    }
    else {
        print "\n* Using default integrated template\n" if defined $verbose;
    }
    return $res;
}

__END__

=head1 Usage

MyRPM [OPTION]

MyRPM is a automatic spec file generator and builder.

Myrpm allow you to install freely software on a rpm compliant system
and realize a binary package from a list of file.

This program manages rigths and users. It s a simple tool that simplify
packaging in chroot mode.

=head1 General Options

 -h, --help				: Print this help.
 -v, --verbose				: Print debug information, verbose mode.
 -m, --multiple				: Split into 3 packages : main, doc and config
 -b, --build				: Build the package automatically at the end.
 -a, --archive=filename			: RPM Creation based on a archive file
 -u, --uid=user id or name		: User id for archive file
 -g, --gid=user id or name		: Group id for archive file
 -n, --nodoc				: Avoid documentation file detection
 -i, --nostip				: Avoid binary stripping
 -c, --noconfig				: Avoid config file detection
 -s, --noreserved			: Avoid reserved directory
 -t, --template=filename			: Generate the spec skeleton from this template.
 -x, --exclude="pattern1,pattern2"	: Exclude some file patterns.
 -r, --root-directory=<directory>	: Root directory ( / by default ).
 -d, --directory=<directory>		: Directory where is the tree to package
 by default, list of files is build from the stdin data
 -o, --optimize				: Try to perform a file list optimisation

=head1 Package Options

 -N, --name=<name>			: Package name - This option is mandatory
 -V, --version=<version>		: Package version - This option is mandatory
 -R, --release=<release>		: Package release - This option is mandatory
 -C, --changelog=<changelog>		: Package changeLog
 -D, --description=<description>	: Package Description.
 -S, --summary=<summary>		: Package Summary.
 -P, --packager=<packager>		: Packager identity.
 -U, --vendor-url=<vendor url>		: Vendor URL.
 -O, --vendor=<vendor>			: Vendor name.
 -A, --architecture=<archi>		: Target architecture.
 -T, --distribution=<distro>		: Target distribution.
 --requires=<dependency>,...		: Dependency list.
 --build-script=<filename>		: Script filename to include in the %build session.
 --pre-script=<filename>		: Script filename to include in the %pre session.
 --post-script=<filename>		: Script filename to include in the %post session.
 --preun-script=<filename>		: Script filename to include in the %preun session.
 --postun-script=<filename>		: Script filename to include in the %postun session.

=head1 Examples

=head2 Realize a kick rpm snapshot of /home/jmrenouard/myrpmBuildDir

MyRPM -v -d /home/jmrenouard/myrpmBuildDir -r /home/jmrenouard/myrpmBuildDir -N toto -V 1.0 -R 1 -b

=head2 An other version

cd /home/jmrenouard/myrpmBuildDir && MyRPM -v -d . -r . -N toto -V 1.0 -R 1 -b

=head2 The same with UNIX tools interaction

cd /home/jmrenouard/myrpmBuildDir && find `pwd` -iname '*' -print | MyRPM -v -r /home/jmrenouard/myrpmBuildDir -N toto -V 1.0 -R 1 -b

find /home/jmrenouard/myrpmBuildDir | MyRPM -r /home/jmrenouard/myrpmBuildDir -N toto -V 1.0 -R 1

=head2 Explanations

This script performs the following operations :

Find build the list of all the files in /home/jmrenouard/myrpmBuildDir.

MyRPM packages all the files /home/jmrenouard/myrpmBuildDir  in a package with toto as name.

MyRPM consider /home/jmrenouard/myrpmBuildDir as the root of all the files so all this files will be installed from the root file system by the rpm program.


=head2 Repackage existing configuration

rpm -ql yum |  MyRPM -v -N yum -V 2.7 -R 1_jmr -b

=head2 Explanations

Rpm gives the list of the files in the yum package installed on the system.

MyRPM packages all the files in a package with yum as name and 1_jmr as release.

This is a new way to package modification on a installed system.

=head1 Others features as is

This tools handles user and group creation. When building RPM, myrpm embeds groups and users
information and build a package which check groups and users before installing files.

MyRPM supports also symbolic links so that you can easy substitute "current" link after install.

MyRPM is proven in production environment can build big RPM easily.
MyRPM supports fuzzy file names such as innner class files generated by javac.

MyRPM supports pre and post install uninstall scripts.

=head1 Configuration file samples

Myrpm tool is an ecology-friendly configurated.

=head2 Standard $HOME/.rpmmacros sample

%_topdir	/home/jmrenouard/redhat
%packager	Jean-Marie Renouard<jmrenouard@gmail.com>
%vendor	LightPath
%vendor_url	http://www.jmrenouard.fr
%distribution  Red Hat Enterprise 4/5/6
%dist_tag      .1
%_tmppath   	/var/tmp


=head1 Help to improve this tool

=head2 Submit bugs or remarks at http://code.google.com/p/myrpm/issues/list

=head2 You can also contact me at Jean-Marie Renouard <jmrenouard at gmail.com>

=encoding ISO-8859-15
=head1 Documentation franaise

=head1 Usage

MyRPM [OPTION]

MyRPM est un gnrateur automatique de fichier spec prt  l'emploi.

Myrpm vous prmet d'installer des logiciel librement sur un systme Linux compatible RPM
et de raliser des paquets RPMs binaires depuis une liste de fichiers.

Ce programme gre les droits et les utilisaterus. C'est un outil simple qui simplifie le packaging
en mode non privilgi.

=head1 Options gnrales

 -h, --help				: Affichage de l'aide en ligne.
 -v, --verbose				: Mode verbeux, affichage d'information de deboggage.
 -b, --build				: Compilation automatique du package.
 -a, --archive=filename			: Cration d'un RPM  partir d'une archive
 -u, --uid=user id or name		: Identifiant utilisateur pour l'archive
 -g, --gid=user id or name		: Identifiant de groupe pour l'archive
 -n, --nodoc				: Annulation de la detection des fichiers de documentation
 -i, --nostip				: Annulation de du retrait des informations des binaires
 -c, --noconfig				: Annulation de la detection des fichiers de configuration
 -s, --noreserved			: Annulation de la detection des repertoires rservs
 -m, --multiple 			: Sparation en 3 packets : principal, doc et config
 -t, --template=filename		: Spcification d'un fichier template aternatif.
 -x, --exclude="pattern1,pattern2"	: Exclusion de certaines formes de fichier.
 -r, --root-directory=<directory>	: Rpertoire racine  ( / par dfaut ).
 -d, --directory=<directory>		: Rpertoire  packager.
 Par dfaut, la liste de fichiers est construite depuis le flux d'entre standard.
 -o, --optimize				: Tente d'optimiser la taille de la liste de fichier

=head1 Options du package RPM

 -N, --name=<name>			: Nom du package - Option obligatoire.
 -V, --version=<version>		: Version du package - Option obligatoire.
 -R, --release=<release>		: Release du package - Option obligatoire.
 -C, --changelog=<changelog>		: ChangeLog du package
 -D, --description=<description>	: Description du package.
 -S, --summary=<summary>		: Rsum du package.
 -P, --packager=<packager>		: Identit du packageur.
 -U, --vendor-url=<vendor url>		: URL du fournisseur.
 -O, --vendor=<vendor>			: Nom du fournisseur.
 -A, --architecture=<archi>		: Architecture cible.
 -T, --distribution=<distro>		: Distribution cible.
 --requires=<dependency>,...		: Liste des dpendances.
 --build-script=<filename>		: Nom du script  inclure dans la session %build.
 --pre-script=<filename>		: Nom du script  inclure dans la session %pre.
 --post-script=<filename>		: Nom du script  inclure dans la session %post.
 --preun-script=<filename>		: Nom du script  inclure dans la session %preun.
 --postun-script=<filename>		: Nom du script  inclure dans la session %postun.

=head1 Exemples

=head2 Ralisation rapide d'une image du rpertoire /home/jmrenouard/myrpmBuildDir

MyRPM -v -d /home/jmrenouard/myrpmBuildDir -r /home/jmrenouard/myrpmBuildDir -N toto -V 1.0 -R 1 -b

=head2 Une autre version

cd /home/jmrenouard/myrpmBuildDir && MyRPM -v -d . -r . -N toto -V 1.0 -R 1 -b

=head2 La mme avec des interactions avec les outils UNIX

cd /home/jmrenouard/myrpmBuildDir && find `pwd` -iname '*' -print | MyRPM -v -r /home/jmrenouard/myrpmBuildDir -N toto -V 1.0 -R 1 -b

find /home/jmrenouard/myrpmBuildDir | MyRPM -r /home/jmrenouard/myrpmBuildDir -N toto -V 1.0 -R 1

=head2 Explications

Le script ralise les oprations suivantes :

Find construit la liste de tous les fichiers contenus dans le rpertoie /home/jmrenouard/myrpmBuildDir.

MyRPM packages  tous les fichiers du rpertoie /home/jmrenouard/myrpmBuildDir dans le package ayant toto comme nom, 1.0 comme version et 1 comme release.

MyRPM considre /home/jmrenouard/myrpmBuildDir comme rpertoire root ( / ) si bien que tous les fichiers seront install  la racine par le programme rpm.


=head2 Repackager une configuration existante

rpm -ql yum |  MyRPM -v -N yum -V 2.7 -R 1_jmr -b

=head2 Explications

Rpm donne la liste des fichiers du package Yum install sur le systme.

MyRPM packages tous les fichiers de ce package dans un nouveau package avec yum comme nom.

Il s'agit d'un nouveau moyen de packager des modifications depuis un systme install.

=head1 Autres fonctionnalits

MyRPM support la cration de compte utilisateur et des   groupes. A la cration du RPM, MyRPM embarque les informations sur les groupes et utilisateurs.
MyRPM construit des packages intelligents capable de vrifier la prsence de groupes et utilisateurs avant l'installation des fichiers .

MyRPM supporte aussi les liens symboliquesce qui facilite la substitution des liens "courant" aprs installation.

MyRPM est prouv en environnementde production et peut construire des RPMs volumineux facilement.
MyRPM supporte galement les noms de fichiers tordus tel que les fichiers compilsjava pour les classes internes.

MyRPM supporte l'ensemble des scripts  de pre et post install uninstall.


=head1 Exemple de fichier de configuration

Myrpm utilise le fichier utilisateur pour configurer les valeurs par dfaut.

=head2 Exemples de $HOME/.rpmmacros standard

%_topdir	/home/jmrenouard/redhat
%packager	Jean-Marie Renouard<jmrenouard@gmail.com>
%vendor	LightPath
%vendor_url	http://www.jmrenouard.fr
%distribution  Red Hat Enterprise 4/5/6
%dist_tag      .1
%_tmppath   	/var/tmp

=head1 Aide  l'amlioration du produit

=head2 Merci de soumettre les erreurs et les remarques sur http://code.google.com/p/myrpm/issues/list

=head2 Vous pouvez contactez Jean-Marie Renouard <jmrenouard at gmail.com> pour plus de dtails.
