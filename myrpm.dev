#!/usr/bin/perl 

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"perl5/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle
    pairmap pairgrep pairfirst pairs pairkeys pairvalues
  );
  our $VERSION    = "1.38";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 $b = any { BLOCK } @list
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 $b = all { BLOCK } @list
  
  Similar to C<any>, except that it requires all elements of the C<@list> to make
  the C<BLOCK> return true. If any element returns false, then it returns false.
  If the C<BLOCK> never returns false or the C<@list> was empty then it returns
  true.
  
  =head2 $b = none { BLOCK } @list
  
  =head2 $b = notall { BLOCK } @list
  
  Similar to C<any> and C<all>, but with the return sense inverted. C<none>
  returns true only if no value in the LIST causes the BLOCK to return true, and
  C<notall> returns true only if not all of the values do.
  
  =head2 $val = first { BLOCK } @list
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 $num = max @list
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 $str = maxstr @list
  
  Similar to C<max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 $num = min @list
  
  Similar to C<max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 $str = minstr @list
  
  Similar to C<min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 $num = product @list
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 $num_or_undef = sum @list
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 $num = sum0 @list
  
  Similar to C<sum>, except this returns 0 when given an empty list, rather than
  C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  =cut
  
  =head2 @kvlist = pairgrep { BLOCK } @kvlist
  
  =head2 $count = pairgrep { BLOCK } @kvlist
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 ( $key, $val ) = pairfirst { BLOCK } @kvlist
  
  =head2 $found = pairfirst { BLOCK } @kvlist
  
  Similar to the C<first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 @list = pairmap { BLOCK } @kvlist
  
  =head2 $count = pairmap { BLOCK } @kvlist
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 @pairs = pairs @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of ARRAY references, each containing two items from the given
  list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach ( pairs @KVLIST ) {
         my ( $key, $value ) = @$_;
         ...
      }
  
  =head2 @keys = pairkeys @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 @values = pairvalues @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 @values = shuffle @values
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =cut
  
  =head1 KNOWN BUGS
  
  With perl versions prior to 5.005 there are some cases where reduce will return
  an incorrect result. This will show up as test 7 of reduce.t failing.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
PERL5_LIST_UTIL

$fatpacked{"perl5/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use List::Util;
  
  our $VERSION = "1.38";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
PERL5_LIST_UTIL_XS

$fatpacked{"perl5/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  require Exporter;
  require List::Util; # List::Util loads the XS
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype tainted
  );
  our $VERSION    = "1.38";
  $VERSION   = eval $VERSION;
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 $pkg = blessed( $ref )
  
  If C<$ref> is a blessed reference the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 $addr = refaddr( $ref )
  
  If C<$ref> is reference the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 $type = reftype( $ref )
  
  If C<$ref> is a reference the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken( REF )
  
  The lvalue C<REF> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken( REF )
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  C<weaken()>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 $weak = isweak( $ref )
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 $var = dualvar( $num, $string )
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 $dual = isdual( $var )
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be dual-valued variable, it is actually
  implemented using a tied scalar:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 $vstring = isvstring( $var )
  
  If C<$var> is a scalar which was coded as a vstring the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 $isnum = looks_like_number( $var )
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 $fh = openhandle( $fh )
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 $ro = readonly( $var )
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 $code = set_prototype( $code, $prototype )
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 $t = tainted( $var )
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use C<isweak> or C<weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  C<isvstring> you will need to use a newer release of perl.
  
  =item C<NAME> is only available with the XS version of Scalar::Util
  
  C<Scalar::Util> contains both perl and C implementations of many of its
  functions so that those without access to a C compiler may still use it.
  However some of the functions are only available when a C compiler was
  available to compile the XS version of the extension.
  
  At present that list is: weaken, isweak, dualvar, isvstring, set_prototype
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Except weaken and isweak which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  =cut
PERL5_SCALAR_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#------------------------------------------------------------------------------
#
# MyRPM - Rpm Utilities
# Copyright (c) Jean-Marie RENOUARD 2014 - LightPath
# Contact : Jean-Marie Renouard <jmrenouard at gmail.com>
#
# This program is open source, licensed under the Artistic Licence v2.0.
#
# Artistic Licence 2.0
# Everyone is permitted to copy and distribute verbatim copies of 
# this license document, but changing it is not allowed.
#
#------------------------------------------------------------------------------
#
#CURRENT WORK IN PROGRESSS
# ENLIGHTMENT ROAD
# FEA 0  : Using RPM::SpecFile Module
# FEA 1  : Data model rewrite
# FEA 2  : Switch to Template::Magic instead of Text::Template
# FEA 3  : Include RPM Signing
# FEA 4  : Include Building RPM with rpmbuild
# FEA 5  : Include init building environment steps
# FEA 6  : Adding optionnal rpmlint review
# FEA 7  : Adding repository management: create, update and fan out
# FEA 8  : Pass all corrections for perl critics
# FEA 9  : config from rpm --showrc
# FEA 10 : autobuild list for install
# FEA 11 : Simplify arbo big work to do  !!!
# FEA 12 : correct handling for dirAlias %{_usr} and %{_bindir}
# FEA 13 : template for user and group creation
# FEA 14 : template for user and group creation
# FEA 15 : fatpack script

use warnings;
use strict;
use Text::Template;
use Archive::Tar;
use File::stat;
use File::Path;
use Getopt::Long;
use File::Find;
use File::Basename;
use File::Spec;
use Cwd;
use Carp qw(confess);
# Perl trim function to remove whitespace from the start and end of the string
sub trim {
    my $string = shift;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}
my $version_number = "5.38";
printError("Wrong parameter : -N, -V ,-R at least\n$0 -h for help\n") if ( $#ARGV == 0 );

### Constant Configuration section
my @reserved_dirs = (
    '^\/bin$',    '^\/sbin$',       '^\/dev$',      '^\/home$',
    '^\/lib$',    '^\/media$',      '^\/mnt$',      '^\/proc$',
    '^\/srv$',    '^\/tmp$',        '^\/var\/log$', '^\/var\/lib$',
    '^\/var$',    '^\/boot$',       '^\/etc$',      '^\/etc\/rc.d',
    '^\/initrd$', '^\/lost+found$', '^\/root$',     '^\/selinux$',
    '^\/sys$',    '^\/usr$',        '\/usr\/sbin$', '\/usr\/bin$'
);

my @config_pattern = (
    "\.cnf", "etc",
    "initrd", "\.conf", "\.properties", "\.cnf",
    "\.ini",  "\.xml", "\.yaml", "\.json"
);
my @doc_pattern =
  ( "doc", "\.txt", "README", "LICENCE", "LICENSE", 
  "TODO", "\.html", "\.tex", "\.txt", "\.pdf" );

my %dirAlias = (
    "/usr/lib64"     => "%{_libdir}",
    "/usr/sbin"    => "%{_sbindir}",
    "/usr/bin"     => "%{_bindir}",
    "/usr/libexec" => "%{_libexecdir}",
    "/usr/share"   => "%{_datadir}",
    "/var"         => "%{_var}",

    #New problem to avoid
    #	"/usr"	       => "%{_usr}",
    # "/usr/lib"     => "%{_libdir}",
);
my $macrosFile = $ENV{'HOME'} . "/.rpmmacros";

my $topdir          = getParameterFromConfig( "_topdir", "/usr/src/redhat" );
my $specDir         = $topdir . "/SPECS";
my $srcDir          = $topdir . "/SOURCES";
my $archiveRootPath = "/tmp/myrpm";

### Misc declaration section
# Var to store each line
my $line = q();

# File list
my @files     = ();
my @instFiles = ();
my @instDirs  = ();

my @defFiles     = ();
my @defConfFiles = ();
my @defDocFiles  = ();

### Command line option section
Getopt::Long::Configure('bundling');

my (
    $help,          $build,           $verbose,     $multi,
    $templateName,  $root_dir,        $snap_dir,    $Name,
    $Version,       $Release,         $Description, $Summary,
    $ChangeLog,     $Packager,        $Vendor,      $VendorUrl,
    $Archi,         $Distro,          $archive,     $requires_string,
    $pre_script,    $build_script,    $post_script, $preun_script,
    $postun_script, $exclude_pattern, $uid,         $gid,
    $nodoc,         $noconf,          $nores,       $optimize,
    $nostrip,
);

GetOptions(
    "h|help"             => \$help,
    "b|build"            => \$build, 
    "v|verbose"          => \$verbose,
    "m|multiple"         => \$multi,
    "t|template=s"       => \$templateName,
    "r|root-directory=s" => \$root_dir,
    "d|directory=s"      => \$snap_dir,
    "x|exclude=s"        => \$exclude_pattern,
    "a|archive=s"        => \$archive,
    "u|uid=s"            => \$uid,
    "g|gid=s"            => \$gid,
    "n|nodoc"            => \$nodoc,
    "i|nostrip"          => \$nostrip,
    "c|noconfig"         => \$noconf,
    "s|noreserved"       => \$nores,
    "o|optimize"         => \$optimize,
    "N|name=s"           => \$Name,
    "V|version=s"        => \$Version,
    "R|release=s"        => \$Release,
    "C|changelog=s"      => \$ChangeLog,
    "D|description=s"    => \$Description,
    "S|summary=s"        => \$Summary,
    "P|packager=s"       => \$Packager,
    "O|vendor=s"         => \$Vendor,
    "U|url-vendor=s"     => \$VendorUrl,
    "A|architecture=s"   => \$Archi,
    "T|distribution=s"   => \$Distro,
    "I|sign"   => \$Distro,
    "requires=s"         => \$requires_string,
    "pre-script=s"       => \$pre_script,
    "post-script=s"      => \$post_script,
    "preun-script=s"     => \$preun_script,
    "postun-script=s"    => \$postun_script,
    "build-script=s"     => \$build_script
);

printUsage($0) if defined $help;

($templateName) || ( $templateName = shift ) || ( $templateName = q() );
($root_dir)     || ( $root_dir     = shift ) || ( $root_dir     = q() );
$root_dir =~ s/\/$//;

($snap_dir) || ( $snap_dir = shift ) || ( $snap_dir = q() );
$snap_dir =~ s/\/$//;

($exclude_pattern)
  || ( $exclude_pattern = shift )
  || ( $exclude_pattern = q() );

($archive) || ( $archive = shift ) || ( $archive = undef );

($uid) || ( $uid = shift ) || ( $uid = 0 );
($gid) || ( $gid = shift ) || ( $gid = 0 );
($Name) || ( $Name = shift ) || ( printError("Missing -N option : mandatory") );
($Version)
  || ( $Version = shift )
  || ( printError("Missing -V option : mandatory") );
($Release)
  || ( $Release = shift )
  || ( printError("Missing -R option : mandatory") );
($ChangeLog)
  || ( $ChangeLog = shift )
  || ( $ChangeLog = "http://www.jmrenouard.fr - RPM solution provider" );

($Description)
  || ( $Description = shift )
  || ( $Description = "Package $Name-$Version-$Release" );
($Summary)
  || ( $Summary = shift )
  || ( $Summary = "This package is used for $Name-$Version-$Release" );
($Packager)
  || ( $Packager = shift )
  || ( $Packager =
    getParameterFromConfig( "packager", "jmrenouard\@gmail.com" ) );
($Vendor)
  || ( $Vendor = shift )
  || ( $Vendor = getParameterFromConfig( "vendor", "LightPath" ) );
($VendorUrl)
  || ( $VendorUrl = shift )
  || ( $VendorUrl =
    getParameterFromConfig( "vendor_url", "http://www.jmrenouard.fr" ) );
($Archi)
  || ( $Archi = shift )
  || ( $Archi = getParameterFromConfig( "_arch", `arch` ) );
($Distro)
  || ( $Distro = shift )
  || ( $Distro = getParameterFromConfig( "_dist", "Generic Red Hat" ) );

($pre_script) || ( $pre_script = shift ) || ( $pre_script = q() );
print "\n * pre : $pre_script" if defined $verbose;

($preun_script) || ( $preun_script = shift ) || ( $preun_script = q() );
print "\n * preun : $preun_script" if defined $verbose;

($post_script) || ( $post_script = shift ) || ( $post_script = q() );
print "\n * post : $post_script" if defined $verbose;

($postun_script) || ( $postun_script = shift ) || ( $postun_script = q() );
print "\n * postun : $postun_script" if defined $verbose;

($build_script) || ( $build_script = shift ) || ( $build_script = q() );
print "\n * install : $build_script" if defined $verbose;

($requires_string)
  || ( $requires_string = shift )
  || ( $requires_string = q() );
print "\n * requires info : $requires_string" if defined $verbose;

my @reqs = split( q/,/, $requires_string );

@doc_pattern    = () if defined $nodoc;
@config_pattern = () if defined $noconf;
@reserved_dirs  = () if defined $nores;

### Checking arguments section
print "\t * Version : " . $version_number . "\n" if defined $verbose;

my %lusers;
my %lgroups;

### Version : $Version
printError("Wrong version format : XX.YY;ZZ, XX.YY, ...")
  unless ( $Version =~ /^[0-9][0-9\.]*$/ );
print "Checking version : $Version: OK\n" if defined $verbose;

### Release : $Release
printError("Wrong release format : X without dots")
  unless ( $Release =~ /^[1-9][0-9]*$/ );
print "Checking release : $Release: OK\n" if defined $verbose;

### Archive mode detection
### Archive file : $archive
my $tmp_dir = undef;
if ( defined $archive ) {
    ### Archive handling section
    # check archive permissions
    printError("Unable to read archive file $archive") unless -r $archive;

    # Create temporary dir
    $snap_dir = "$archiveRootPath/$$";
    $tmp_dir  = "$snap_dir/$root_dir";
    print "\n * Try to create $tmp_dir" if defined $verbose;
    eval { mkpath($tmp_dir) };
    if ($@) {
        print "\n * Couldn't create $tmp_dir: $@";
    }
    print "\n* $tmp_dir created." if defined $verbose;
    my $cwdir = getcwd;
    chdir $tmp_dir;

    my $compressed_archive = ( $archive =~ /.+?\.(?:tar\.gz|tgz)$/i );
    my $arch_obj = Archive::Tar->new( $archive, $compressed_archive );
    $arch_obj->extract();

    #change uid if necessary
    print "\n* $uid($gid) rigths setting." if defined $verbose;
    $uid = getUserId($uid);
    $gid = getGroupId($gid);
    find(
        sub {
            print "\n * setting rigths for $_" if defined $verbose;
            chown $uid, $gid, $_;
        },
        $tmp_dir
    );
    chdir $cwdir;

    #Priority for archive option
    $root_dir = $snap_dir;
}

###Checking directories section
my $current_dir = getcwd;
### Cwd: $current_dir
$root_dir = trim $current_dir if ( $root_dir =~ /^\.$/ );

### Root Dir: $root_dir
print "Root directory : ==>$root_dir<==\n" if defined $verbose;
printError("Root dir doesnt exists or is empty")
  unless ( -d $root_dir || $root_dir eq q() );
print "Checking root_dir OK\n" if defined $verbose;

$snap_dir = trim $current_dir if ( $snap_dir =~ /^\.$/ );
### Snap dir : $snap_dir
print "Snap directory : ==>$snap_dir<==\n" if defined $verbose;
printError("Snapshot dir doesn t exist or is empty")
  unless ( -d $snap_dir || $snap_dir eq q() );
print "Checking snap_dir OK\n" if defined $verbose;

my @inputFileList = getInputFileLine($snap_dir);

### Pattern exclusion section
my @exclude_patterns = ();
@exclude_patterns = split q/,/ , $exclude_pattern
  if ( $exclude_pattern ne q() );

### Exclude patterns : @exclude_patterns
my %user_infos  = getUserMap();
my %group_infos = getGroupMap();

my %used_users     = ();
my %used_groups    = ();
my %symbolic_links = ();

### Start handling file list
foreach (@inputFileList) {    ### Evaluating [===|    ] % done
                              #sleep 2;
    my $line = $_;

    # Removing empty line
    next if ( $line eq q() );

    printError("Unable to read item : $line") unless -r $line || -l $line;

    #Translation of all line starting by a ./something into a absolute path
### Original File : $line
    $line = File::Spec->rel2abs($line);
### Absolute File : $line

    #The root dir is excluded
    next if ( $line eq $root_dir );

    my $pattern_found = 0;
    foreach (@exclude_patterns) {
        if ( $line =~ /$_/ ) {
            $pattern_found = 1;
            print "* Pattern found : $pattern_found for $line\n\n "
              if defined $verbose;
            last;
        }
    }

    next if ( $pattern_found == 1 );
    my $line_chrooted = $line;

    # Removing root_dir entry
    next if ( $line_chrooted eq $root_dir );

### $line is not excluded
    $line_chrooted =~ s/^$root_dir\///;
    print "OK for $line_chrooted" if defined $verbose;

    print "\n* Traitement de '$line'" if defined $verbose;
### Chrooted line : $line_chrooted
    #Symbolic link handling
    if ( -l $line ) {
        ### $line is symbolic link
        my $lnkName=readlink($line);

        my $pointedItem = File::Spec->rel2abs( $lnkName );
	$pointedItem =~ s/^$root_dir\///;

	#fix for . link
	$pointedItem=$lnkName if ( $lnkName eq "." or $lnkName eq "./" );
	
        ### LINK: /$line_chrooted 
	### DEST: $pointedItem

        $symbolic_links{ "/" . $line_chrooted } = $pointedItem;
        next;
    }
    confess(" $line does nt exists") unless ( -e $line );

    my $statFile = stat($line);
    my $mode     = $statFile->mode;
    my $uid      = $statFile->uid;
    my $gid      = $statFile->gid;

    print "\n* UID $uid GID : $gid" if defined $verbose;
    $used_users{$uid}++;
    $used_groups{$gid}++;
    confess ("$line without uid") unless defined $uid;
    confess ("$line without gid") unless defined $gid;

    print "\n * USED USERS :",  join ',', keys %used_users  if defined $verbose;
    print "\n * USED GROUPS :", join ',', keys %used_groups if defined $verbose;

    confess ("$line without valid uid name") unless defined $user_infos{$uid}{'name'};
    confess ("$line without valid gid name") unless defined $group_infos{$gid}{'name'};
    
    print "\n* user=", $user_infos{$uid}{'name'}   if defined $verbose;
    print "\n* group=", $group_infos{$gid}{'name'} if defined $verbose;

    my $trueMode = sprintf( "%04o", $mode & 07777 );
    push @files, "./$line_chrooted";
    print "\n\t * $line into Tar ball....\n" if defined $verbose;
    print "\t * $line and $line_chrooted into Spec file....\n"
      if defined $verbose;

    my $final_path = substituteAliasDir("/$line_chrooted");

    my %tmpData = ();
    $tmpData{mode}   = $trueMode;
    $tmpData{r_file}   = $line_chrooted;
    $tmpData{d_file}   = escapeDollarChars($line_chrooted);
    #print "\n~~~~~~~~~~~~~ $line_chrooted";
    $tmpData{file}   = escapeParChars($line_chrooted);
    $tmpData{r_path}   = $final_path;
    $tmpData{se_path}   = escapeSpaceChars($final_path);
    $tmpData{Se_path}   = escapeParChars($final_path);
    $tmpData{sSe_path}   = escapeSpaceChars (escapeParChars($final_path));
    $tmpData{psd_path}   = escapeDollarChars (escapeSpaceChars (escapeParChars($final_path)));
    $tmpData{pd_path}   = escapeDollarChars (escapeSpaceChars (escapeParChars($final_path)));
  #  $tmpData{r_path} = $final_path;
    $tmpData{uid}    = $user_infos{$uid}{'name'};
    $tmpData{gid}    = $group_infos{$gid}{'name'};

    #File case
    if ( -f "$line" ) {
        push @instFiles, \%tmpData;

        my $isDoc    = isDocFile("/$line_chrooted");
        my $isConfig = isConfigFile("/$line_chrooted");

        # Fix bug if is config and is doc at the same time
        #Choice to be a config file
        $isDoc = 0 if ( $isDoc && $isConfig );

        push @defFiles, \%tmpData if ( !$isDoc && !$isConfig );
        push @defConfFiles, \%tmpData if ($isConfig);
        push @defDocFiles,  \%tmpData if ($isDoc);
    }

    # Directory case
    # Must not be a reserved directory
    if ( -d "$line" ) {
        $tmpData{comment} = 1 if isReservedDir("/$line_chrooted");
        $tmpData{isDir} = 1;
        push @instDirs, \%tmpData;

        push @defFiles, \%tmpData if ( !isReservedDir("/$line_chrooted") );
    }
}    ### -End handling file list

### Summary First $snap_dir Analyse
### Installation File List : @instFiles
### Installation Dir  List : @instDirs
### Definition File List : @defFiles
### Definition Configuration file List : @defConfFiles
### Definition Documentation file List : @defDocFiles

# Heuristic arbo simplification
my @rootDirs = ();
if ( defined $optimize ) {
    ### Optimisation activated
    foreach my $dirItem (@instDirs) {
        my $parentDir = dirname( $$dirItem{file} );

        push @rootDirs, $dirItem if ( $parentDir eq "." );
        @{ $$dirItem{subFolder} } = ();
        foreach my $subFolder (@instDirs) {
            push @{ $$dirItem{subFolder} }, $subFolder
              if dirname( $$subFolder{file} ) eq $$dirItem{file};
        }

        @{ $$dirItem{subFiles} } = ();
        foreach my $subFile (@defFiles) {
            push @{ $$dirItem{subFiles} }, $subFile
              if !defined $$subFile{isDir}
                  and dirname( $$subFile{file} ) eq $$dirItem{file};
        }

        @{ $$dirItem{subConf} } = ();
        foreach my $subFile (@defConfFiles) {
            push @{ $$dirItem{subConf} }, $subFile
              if dirname( $$subFile{file} ) eq $$dirItem{file};
        }

        @{ $$dirItem{subDoc} } = ();
        foreach my $subFile (@defDocFiles) {
            push @{ $$dirItem{subDoc} }, $subFile
              if dirname( $$subFile{file} ) eq $$dirItem{file};
        }
    }
}

#exit 0 ;

print "\n * uniq uids :" . join ', ', keys %used_users  if defined $verbose;
print "\n * uniq gids :" . join ', ', keys %used_groups if defined $verbose;

#Handling group creation
my @group_creation = ();
foreach ( keys %used_groups ) {

    #Avoid root group creation
    next if ( $_ == 0 );
    push @group_creation, $group_infos{$_};
}

#Handling user creation
my @user_creation = ();
foreach ( keys %used_users ) {

    #avoid root account :)
    #Avoid root user creation
    next if ( $_ == 0 );
    next if ( $_ < 500 );
    next if ( $user_infos{$_}{'shell'} =~ /nologin/ );
    print "\n*" . $user_infos{$_}{'name'} . " in users $_" if defined $verbose;

    # For all non system account
    # password is the same than user name
    # WARNING : Security issues around this feature
    $user_infos{$_}{init} = 1;
    push @user_creation, $user_infos{$_};
}

if ( defined $optimize ) {
    simplifyIt( \@rootDirs, \@defFiles, \@defDocFiles, \@defConfFiles,
        \@instFiles );
### Summary First $snap_dir Analyse
### Installation File List : @instFiles
### Installation Dir  List : @instDirs
### Definition File List : @defFiles
### Definition Configuration file List : @defConfFiles
### Definition Documentation file List : @defDocFiles
### Definition Documentation file List : @defDocFiles
### Definition Root Dirs List : @rootDirs
}

# if a instDir contains only doc or config or file with same user and unix rigths then a * can substitute all included files and directory ( * is ok for file )
#Even if it is in comment
# The process must call the same fonction on its subdirectories first
# About the recursion of the process


my $pre_code = getScriptFileContent($pre_script);

#Handling symbolic link replacement as post install code
my $post_code = getScriptFileContent($post_script);

my $templDef = getSpecTemplate($templateName);

my $template = Text::Template->new(
    SOURCE     => "$templDef",
    TYPE       => 'STRING',
    DELIMITERS => [ "<", ">" ]
) or confess "Couldn't construct template: $Text::Template::ERROR";
    
my %vars = (
    name              => "$Name",
    version           => "$Version",
    release           => "$Release",
    summary           => "$Summary",
    description       => "$Description",
    reqs              => \@reqs,
    packager          => "$Packager",
    vendor            => "$Vendor",
    vendor_url        => "$VendorUrl",
    archi             => "$Archi",
    distro            => "$Distro",
    multiple_packages => defined $multi,
    users             => \@user_creation,
    groups            => \@group_creation,
    nostrip	      => $nostrip,
    #Pre_code must be list
    pre_code => "$pre_code",

    #Post_code must be list
    post_code => "$post_code",

    symbolic_links => \%symbolic_links,
    preun_code     => getScriptFileContent($preun_script),

    postun_code => getScriptFileContent($postun_script),

    build_code => getScriptFileContent($build_script),

    # must be information only
    listOfFiles => \@defFiles,

    # must be information only
    listOfDocFiles => \@defDocFiles,
	
	# must be information only
    listOfConfFiles => \@defConfFiles,

    instFiles => \@instFiles,
    instDirs  => \@instDirs,

    ChangeLog => $ChangeLog,

    # must be information only
    OldChangeLogs => getChangeLogs("$specDir/$Name.spec"),

    #Avoid system call for portability
    date => trim(`unset LANG && date +"%a %b %d %Y"`)
);

my $result = $template->fill_in( HASH => \%vars );

confess "Couldn't fill in template: $Text::Template::ERROR"
  unless ( defined $result );

# Chrrooting in fact
if   ( $root_dir eq q() ) { chdir("/") }
else                      { chdir($root_dir); }

#generate Tarball
my $tar = Archive::Tar->new;
foreach my $file (@files) {
    $file =~ s/^\//\.\//;
    print "\n$file to Archive..." if defined $verbose;
    $tar->add_files($file);
}

$tar->write( "$srcDir/$vars{'name'}-$vars{'version'}.tar.gz", 1 );

#Writing spec file
open my $fh, q(>), "$specDir/$vars{'name'}.spec"
  or printError(
"Unable to open $specDir/$vars{'name'}.spec in write mode. please check permissions for this file or directory"
  );
print $fh $result if defined($result);
print $result if ( defined($result) && $verbose );
close $fh;

# Cleaning archive tmp dir
if ( defined $archive ) {

    # Create temporary dir
    my $tmp_dir = "/tmp/myrpm/$$";
    eval { rmtree($tmp_dir) };
    if ($@) {
        print "Couldn't create $tmp_dir: $@";
    }
}

#Compiling package

#Avoid system call for portability
my $cmd = "rpmbuild --quiet -ba --target=$Archi $specDir/$vars{'name'}.spec";
$cmd="$cmd 1>/dev/null 2>&1" unless ($verbose);

print "\n#Executing to build package : $cmd\n" if ($verbose);
print `$cmd`                                   if ($build);
exit 0;

sub printUsage {
    my $s = shift;
    print `perldoc $s`;
    exit 0;
}

sub printError {
    my @content = @_;
    my $message = join( ' ', @content );
    print STDERR $message;

    exit 1;
}

sub escapeParChars {
    my $line = shift;
    $line =~ s/(\()/\\$1/g;
    $line =~ s/(\))/\\$1/g;
    $line =~ s/(\])/\\$1/g;
    $line =~ s/(\[)/\\$1/g;

    # since a bug with \\
    #$line=~s/(\&))/\\$1/g;
    #$line=~s/(\\)/\\\\/g;
    return $line;
}

sub escapeSpaceChars{
    my $line = shift;
    $line =~ s/(\ )/\\$1/g;
    return $line
}

sub escapeDollarChars{
    my $line = shift;
    $line =~ s/(\$)/\\$1/g;
    return $line
}

sub isReservedDir {
    my $dir = shift;
    print "\n* Testing $dir as reserved" if defined $verbose;
    foreach my $rdir (@reserved_dirs) {
        return 1 if ( $dir =~ /$rdir/i );
    }
    print "\n* $dir is NOT reserved" if defined $verbose;
    return 0;
}

sub isDocFile {
    my $file = shift;
    print "\n* Testing $file as doc" if defined $verbose;
 	foreach my $dpat (@doc_pattern) {
        print ($file =~ /$dpat/);
		return 1 if ( $file =~ /$dpat/ );
    }
    print "\n* $file is NOT doc" if defined $verbose;
    #exit 0;
	return 0;
}

sub isConfigFile {
    my $file = shift;
    print "\n* Testing $file as config" if defined $verbose;
    foreach my $cpat (@config_pattern) {
        return 1 if ( $file =~ /$cpat/ );
    }
    print "\n* $file is NOT config" if defined $verbose;
    return 0;
}

sub substituteAliasDir {
    my $path = shift;

    #my $not_found=1;
    foreach my $subpath ( sort keys %dirAlias ) {

        #break unless ($not_found);
        print "$subpath lookup\n" if defined $verbose;
        if ( $path =~ /^$subpath/ ) {
            my $alias = $dirAlias{$subpath};
            print "=> $subpath FOUND : substitute by : $alias\n"
              if defined $verbose;
            $path =~ s/^$subpath/$alias/;
            print "* Substitution is :" . $path . "\n" if defined $verbose;
            return $path;
        }
    }
    return $path;
}

sub getChangeLogs {
    my $specFile = shift;
    return q() unless ( -f $specFile );
    print "$specFile found...." if defined $verbose;
    my @lines                = getFileContents($specFile);
    my @changeLogs           = ();
    my $changeLogHeaderFound = 0;
    foreach (@lines) {
        push @changeLogs, $_ if $changeLogHeaderFound == 1;
        $changeLogHeaderFound = 1 if /^%changelog/;
    }
    return join( q(), @changeLogs );
}

sub getScriptFileContent {
    my $filename = shift;
    return q() if $filename eq q();
    return q() unless -f $filename;
    my @lines = getFileContents($filename);

    # remove first line
    my $interp;
    if ( defined( $lines[0] ) && $lines[0] =~ /^#!/ ) {

        #$lines[0] =~ s/#!(.*)/$1 << SCRIPT_END/;
        $lines[0] = q();

        #push @lines, "SCRIPT_END";
    }

    return join q(), @lines;
}

sub getFileContents {
    my $filename = shift;
    print "* reading $filename " if defined $verbose;
    my $fh;
    open( $fh, q(<), "$filename" )
      or confess "Couldn't open $filename for reading: $!\n";
    my @lines = <$fh>;

    close($fh);
    return @lines;
}

sub getUserMap {
    my $file         = "/etc/passwd";
    my %localUserMap = ();
    my $fh;
    open( $fh, q(<), $file ) or confess "$file : $!";

    while (<$fh>) {
	chomp($_);
        ### Line : $_
        my ( $user, $passwd, $uid, $gid, $desc, $home, $shell ) =
          split qw/:/, $_;
        next unless defined $user;
        $desc = 'default comment' if ( $desc eq q() );
        $localUserMap{$uid}{'name'}    = $user;
        $localUserMap{$uid}{'gid'}     = $gid;
        $localUserMap{$uid}{'uid'}     = $uid;
        $localUserMap{$uid}{'comment'} = $desc;
        $localUserMap{$uid}{'shell'}   = $shell;
        $localUserMap{$uid}{'home'}    = $home;
    }

    close($fh);
    ### user Map : %localUserMap
    return %localUserMap;
}

sub getUserId {
    my $search_name  = shift;
    my $file         = "/etc/passwd";
    my %localUserMap = ();
    my $fh;
    open( $fh, q(<), "$file" ) or confess "$file : $!";

    while (<$fh>) {
        chomp($_);
        my ( $user, $passwd, $uid, $gid, $desc, $home, $shell ) =
          split qw/:/;
        next unless defined $user;
        return $uid if ( $user eq $search_name );
        return $uid if ( $uid  eq $search_name );
    }

    close($fh);
    return 0;
}

sub getGroupMap {
    my $file          = "/etc/group";
    my %localGroupMap = ();
    my $fh;
    open( $fh, q(<), $file ) or confess "$file : $!";

    while (<$fh>) {
        chomp($_);
        my ( $group, $passwd, $gid, $members ) = split qw/:/;
        $localGroupMap{$gid}{'gid'}     = $gid;
        $localGroupMap{$gid}{'name'}    = $group;
        $localGroupMap{$gid}{'members'} = $members;
    }
    close($fh);
    ### Group Map : %localGroupMap
    return %localGroupMap;
}

sub getGroupId {
    my $search_group = shift;
    my $file         = "/etc/group";
    my $fh;
    open( $fh, q(<), "$file" ) or confess "$file : $!";
    my %localGroupMap = ();
    my $res           = undef;
    while ( not defined($res) and <$fh> ) {
        chomp($_);
        my ( $group, $password, $gid, $members ) = split qw/:/;
        $res = $gid if ( $group eq $search_group or $gid eq $search_group );
    }
    close $fh;
    return $res;
}

sub getUniqElement {
    my %seen = ();
    return grep { !$seen{$_}++ } shift;
}

sub getInputFileLine {
    my $directory = shift;
    print "==>$directory<== ....\n" if defined($verbose);
    my @result = ();
    my $line   = q();
    if ( defined($directory) && ( -d $directory ) ) {
        print "$directory exists....\n" if defined($verbose);

        find sub {
            my $line = $File::Find::name;
            $line .= "/" if -d;

            #print "=> $line\n" if defined($verbose);
            push @result, $line;
        }, ($directory);
    }
    else {
        print "==>INPUT FILE LIST<== ....\n" if defined($verbose);

        while ( defined( $line = <> ) ) {
            $line = trim($line);

            #print "=> $line\n" if defined($verbose);
            push @result, $line;
        }
    }
    print "\n" if defined $verbose;
    return @result;
}


# Retrieve value from files (like .rpmmacros)
sub getParameterFromConfig {
    my $parameter = shift;

    my $res    = shift;
    my $opened = 1;
    my $fh;
    open( $fh, q(<), "$macrosFile" ) || ( $opened = 0 );
    if ($opened) {
        while (<$fh>) {
            if (m/^\%$parameter\s+(.*)$/) {
                $res = $1;
            }
        }

        close($fh);
    }
    return $res;
}

sub simplifyIt {
    my $rootDirs     = shift;
    my $defFiles     = shift;
    my $defDocFiles  = shift;
    my $defConfFiles = shift;
    my $instFiles    = shift;
    return if scalar @{$rootDirs} == 0;
    foreach my $ldir ( @{$rootDirs} ) {
        my $nbChildNode = scalar( @{ $$ldir{subFolder} } );
        print "\t\t nb Child folder : $nbChildNode" if $verbose;
        unless ( $nbChildNode == 0 ) {
            simplifyIt( $$ldir{subFolder}, $defFiles, $defDocFiles,
                $defConfFiles, $instFiles );
        }
        else {
            simplifyOneDir( $ldir, $defFiles, $defDocFiles, $defConfFiles,
                $instFiles );
        }
    }
    return 0;
}

sub simplifyOneDir {
    my $folder       = shift;
    my $defFiles     = shift;
    my $defDocFiles  = shift;
    my $defConfFiles = shift;
    my $instFiles    = shift;

    my $refFiles  = undef;
    my $itemLabel = undef;
    if (    scalar( @{ $$folder{subFiles} } ) > 0
        and scalar( @{ $$folder{subDoc} } ) == 0
        and scalar( @{ $$folder{subConf} } ) == 0 )
    {
        $refFiles  = $defFiles;
        $itemLabel = 'subFiles';
    }
    if (    scalar( @{ $$folder{subFiles} } ) == 0
        and scalar( @{ $$folder{subDoc} } ) > 0
        and scalar( @{ $$folder{subConf} } ) == 0 )
    {
        $refFiles  = $defDocFiles;
        $itemLabel = 'subDoc';
    }
    if (    scalar( @{ $$folder{subFiles} } ) == 0
        and scalar( @{ $$folder{subDoc} } ) == 0
        and scalar( @{ $$folder{subConf} } ) > 0 )
    {
        $refFiles  = $defConfFiles;
        $itemLabel = 'subConf';
    }

    return unless defined($refFiles);

    # Simplify Files section
    my $firstFile = undef;

    #my $isSimple=0;
    my $isSimple = 1;
    foreach my $file ( @{ $$folder{$itemLabel} } ) {
        $firstFile = $file unless defined($firstFile);

     #$isSimple=1 if $file != $firstFile and checkFilesForm( $file, $firstFile);
        $isSimple = 0 unless checkFilesForm( $file, $firstFile );
    }
    print "x" x 40 if $verbose;
    if ($isSimple) {

        #Here IS THE BIG WORK :)
        # remove all
        foreach my $file ( @{ $$folder{$itemLabel} } ) {
            removeFromArray( $refFiles,  $file ) unless $file == $firstFile;
            removeFromArray( $instFiles, $file ) unless $file == $firstFile;
        }
        $$firstFile{r_path} = $$folder{r_path} . "/*";
        $$firstFile{path}   = $$folder{path};
        $$firstFile{file}   = $$folder{file} . "/*";
    }
    return 0;
}

sub removeFromArray {
    my $arr = shift;
    my $elt = shift;
    my $i   = 0;
    foreach my $item ( @{$arr} ) {
        next unless defined $item;
        last if ( $item == $elt );
        $i++;
    }
    @{$arr} = @{$arr}[ 1 .. scalar( @{$arr} ) - 1 ] if ( $i == 0 );
    @{$arr} = @{$arr}[ 0 .. scalar( @{$arr} ) - 2 ]
      if ( $i == scalar( @{$arr} ) - 1 );
    @{$arr} = @{$arr}[ 0 .. $i - 1, $i + 1 .. scalar( @{$arr} ) - 1 ]
      if $i < scalar( @{$arr} );

    return 0;
}

sub checkFilesForm {
    my $f1 = shift;
    my $f2 = shift;

    return 1 if $f1 == $f2;
    return 1
      if $$f1{uid} eq $$f2{uid}
          and $$f1{mode} eq $$f2{mode}
          and $$f1{gid}  eq $$f2{gid};
    return 0;
}

sub getSpecTemplate {

    # THE TEMPLATE
    my $defaultSpecTemplate = << 'EOF';
Summary: 		<$summary> 
Name:			<$name>
Version: 		<$version>
Release:	   	<$release>	
License: 		GPL
URL: 			<$vendor_url>
Source0: 		%{name}-%{version}.tar.gz
Group: 			System/Administration
Vendor:			<$vendor>
Packager:		<$packager>
#Archi: 			<$archi>
<if (@reqs == 0 ) {$OUT.="AutoReqProv: 		no"; } >
BuildRoot: 		%{_tmppath}/%{name}-%{version}-root
< foreach $req (@reqs) { $OUT.= "Requires: $req\n"; }>
%description 
<$description>

< if (@listOfConfFiles != 0) { 
    $OUT.="%package config
Summary: Configuration for $name
Group: System/Administration

%description config
Configuration files for $name
$description";
	} >
<if (@listOfDocFiles != 0) {
	$OUT.="%package doc
Summary: Documentation for $name
Group: System/Administration

%description doc
Documentation files for $name
$description"; 
} >

%prep
#%setup -q 
#-n %{name}-%{version}
%setup -c -q
< if ($nostrip) { $OUT.="%define __strip /bin/true
%define debug_package %{nil}"; }>
%build
<$build_code>
%install
rm -Rf %{buildroot}
mkdir -p %{buildroot}/usr/lib/debug

#Directory installation
< foreach $i (@instDirs) {
    $comment=$$i{comment};
    $file=$$i{r_file};
    $mode=$$i{mode};
    $path=$$i{r_path};
#	$OUT.= "#Uncomment if needed - consider as a reserved dir\n#" if ($comment);
    $OUT.="%{__install} -d -m $mode \"$file\" \"%{buildroot}$path\"\n";

	}>
#Files installation
< foreach $i (@instFiles) {
	$file=$$i{d_file};
	$mode=$$i{mode};
	$path=$$i{psd_path};
	$pdpath=$$i{pd_path};
        $OUT.= "[ -d \"`dirname %{buildroot}$path`\" ] || %{__mkdir_p} \"`dirname %{buildroot}$pdpath`\"\n";
	$OUT.= "%{__install} -m $mode \"$file\" \"%{buildroot}/$file\"\n";
    }>
%pre
<  if (@groups == 0 ) {
	    $OUT.="# No group Creation";
	} else {
	    $OUT.="# Group creation"; 
	    foreach $i (@groups){ 
		$gid=$$i{gid};
		$gname=$$i{name};
		$OUT.="\nif egrep -q \"$gname\" /etc/group; then";
		$OUT.="\n\techo \"#Group $gname already exists !\"";
		$OUT.="\nelse";
		$OUT.="\n\tgroupadd -g $gid $gname";
		$OUT.="\nfi";
	    }
	}
   if (@users == 0 ) {	
		$OUT.="\n# No User Creation";
    } else {
	$OUT.="\n# User creation"; 
	foreach $i (@users) {
	    $uname=$$i{name};
	    $gid=$$i{gid};
	    $shell=$$i{shell};
	    $home=$$i{home};
	    $comment=$$i{comment};
	    $uid=$$i{uid};
	    $is_init=$$i{init};
	    $OUT.="\nif egrep -q \"$uname\" /etc/passwd; then";
	    $OUT.="\n\techo \"User $uname already exists !\"";
	    $OUT.="\nelse";
	    $OUT.="\n\tadduser -u $uid -g $gid -s $shell -d $home -c \"$comment\" $uname && USER_NEW=1 || true";
	    $OUT.="\n\t# Changing password for non priviliged user";
	    $OUT.="\n\techo $uname | passwd --stdin $uname";
	    $OUT.="\nfi";
	}
   }>

< $OUT.="\n$pre_code";>

%post< foreach $i (keys %symbolic_links) {
	    $link=$i;
	    $pointee=$symbolic_links{$i};
	    $OUT.="\n#Symbolic link $i - $pointee";
	    $OUT.="\ncd `dirname $i`";
	    $OUT.="\nrm -fv `basename $i`";
	    $OUT.="\nln -fvs $pointee `basename $i`";
	    $OUT.="\ncd -"; 
	}>
<$post_code>
%preun
<$preun_code>
%postun
<$postun_code>
%clean
rm -Rf %{buildroot}

#Regular file and dir list
%files
< foreach $i (@listOfFiles) { 
	    $mode=$$i{mode};
	    $path=$$i{r_path};
	    $comment=$$i{comment};
	    $uid=$$i{uid};
	    $gid=$$i{gid};
	    $OUT.="#Uncomment if needed !\n#" if (defined $comment);
	    $OUT.="%attr($mode $uid, $gid) ";
	    $OUT.="%dir " if ($$i{isDir});
	    $OUT.="\"$path\"\n";}>
< if ( @listOfConfFiles != 0 ) { $OUT.="#Configuration file list"; }>
< if ( @listOfConfFiles != 0 ) { $OUT.= "%files config"; }>
< foreach $i (@listOfConfFiles) { $OUT.="%attr($$i{mode} $$i{uid}, $$i{gid}) %config \"$$i{Se_path}\"\n"; }>
< if ( @listOfDocFiles != 0 ) { 
		$OUT.= "#Documentation file list\n"; 
		$OUT.= "%files doc\n"; 
}>< foreach $i (@listOfDocFiles) { $OUT.= "%attr($$i{mode} $$i{uid}, $$i{gid}) %doc \"$$i{Se_path}\"\n"; }>
%changelog
* <$date> <$packager> <$name>-<$version>-<$release>
- <$ChangeLog>
-  Generated version.

<$OldChangeLogs>
EOF

    my $fileName = shift;
    my $res      = $defaultSpecTemplate;
    if ( $fileName ne q() ) {
        print "\n* Alternate spec skeleton filename : $fileName\n"
          if defined $verbose;

        my $opened = 1;
        my $fh;
        open( $fh, q(<), "$fileName" ) || ( $opened = 0 );

        if ($opened) {
            $res = q();
            while (<$fh>) {
                $res .= $_;
            }
            close($fh);
        }
    }
    else {
        print "\n* Using default integrated template\n" if defined $verbose;
    }
    return $res;
}

__END__

=head1 Usage

MyRPM [OPTION]

MyRPM is a automatic spec file generator and builder.

Myrpm allow you to install freely software on a rpm compliant system 
and realize a binary package from a list of file. 

This program manages rigths and users. It s a simple tool that simplify 
packaging in chroot mode.

=head1 General Options

 -h, --help				: Print this help.
 -v, --verbose				: Print debug information, verbose mode.
 -m, --multiple				: Split into 3 packages : main, doc and config
 -b, --build				: Build the package automatically at the end.
 -a, --archive=filename			: RPM Creation based on a archive file
 -u, --uid=user id or name		: User id for archive file
 -g, --gid=user id or name		: Group id for archive file
 -n, --nodoc				: Avoid documentation file detection
 -i, --nostip				: Avoid binary stripping 
 -c, --noconfig				: Avoid config file detection
 -s, --noreserved			: Avoid reserved directory
 -t, --template=filename			: Generate the spec skeleton from this template.
 -x, --exclude="pattern1,pattern2"	: Exclude some file patterns.
 -r, --root-directory=<directory>	: Root directory ( / by default ).
 -d, --directory=<directory>		: Directory where is the tree to package
 by default, list of files is build from the stdin data
 -o, --optimize				: Try to perform a file list optimisation

=head1 Package Options 

 -N, --name=<name>			: Package name - This option is mandatory
 -V, --version=<version>		: Package version - This option is mandatory
 -R, --release=<release>		: Package release - This option is mandatory
 -C, --changelog=<changelog>		: Package changeLog
 -D, --description=<description>	: Package Description.
 -S, --summary=<summary>		: Package Summary.
 -P, --packager=<packager>		: Packager identity.
 -U, --vendor-url=<vendor url>		: Vendor URL.
 -O, --vendor=<vendor>			: Vendor name.
 -A, --architecture=<archi>		: Target architecture.
 -T, --distribution=<distro>		: Target distribution.
 --requires=<dependency>,...		: Dependency list.
 --build-script=<filename>		: Script filename to include in the %build session.
 --pre-script=<filename>		: Script filename to include in the %pre session.
 --post-script=<filename>		: Script filename to include in the %post session.
 --preun-script=<filename>		: Script filename to include in the %preun session.
 --postun-script=<filename>		: Script filename to include in the %postun session.

=head1 Examples 

=head2 Realize a kick rpm snapshot of /home/jmrenouard/myrpmBuildDir

MyRPM -v -d /home/jmrenouard/myrpmBuildDir -r /home/jmrenouard/myrpmBuildDir -N toto -V 1.0 -R 1 -b

=head2 An other version

cd /home/jmrenouard/myrpmBuildDir && MyRPM -v -d . -r . -N toto -V 1.0 -R 1 -b

=head2 The same with UNIX tools interaction

cd /home/jmrenouard/myrpmBuildDir && find `pwd` -iname '*' -print | MyRPM -v -r /home/jmrenouard/myrpmBuildDir -N toto -V 1.0 -R 1 -b

find /home/jmrenouard/myrpmBuildDir | MyRPM -r /home/jmrenouard/myrpmBuildDir -N toto -V 1.0 -R 1

=head2 Explanations

This script performs the following operations :

Find build the list of all the files in /home/jmrenouard/myrpmBuildDir.

MyRPM packages all the files /home/jmrenouard/myrpmBuildDir  in a package with toto as name.

MyRPM consider /home/jmrenouard/myrpmBuildDir as the root of all the files so all this files will be installed from the root file system by the rpm program.


=head2 Repackage existing configuration

rpm -ql yum |  MyRPM -v -N yum -V 2.7 -R 1_jmr -b

=head2 Explanations

Rpm gives the list of the files in the yum package installed on the system.

MyRPM packages all the files in a package with yum as name and 1_jmr as release.

This is a new way to package modification on a installed system.

=head1 Others features as is

This tools handles user and group creation. When building RPM, myrpm embeds groups and users
information and build a package which check groups and users before installing files.

MyRPM supports also symbolic links so that you can easy substitute "current" link after install.

MyRPM is proven in production environment can build big RPM easily.
MyRPM supports fuzzy file names such as innner class files generated by javac.

MyRPM supports pre and post install uninstall scripts.

=head1 Configuration file samples

Myrpm tool is an ecology-friendly configurated.

=head2 Standard $HOME/.rpmmacros sample

%_topdir	/home/jmrenouard/redhat
%packager	Jean-Marie Renouard<jmrenouard@gmail.com>
%vendor	LightPath
%vendor_url	http://www.jmrenouard.fr
%distribution  Red Hat Enterprise 4/5/6
%dist_tag      .1
%_tmppath   	/var/tmp


=head1 Help to improve this tool

=head2 Submit bugs or remarks at http://code.google.com/p/myrpm/issues/list 

=head2 You can also contact me at Jean-Marie Renouard <jmrenouard at gmail.com>

=encoding ISO-8859-15
=head1 Documentation franaise

=head1 Usage

MyRPM [OPTION]

MyRPM est un gnrateur automatique de fichier spec prt  l'emploi.

Myrpm vous prmet d'installer des logiciel librement sur un systme Linux compatible RPM 
et de raliser des paquets RPMs binaires depuis une liste de fichiers. 

Ce programme gre les droits et les utilisaterus. C'est un outil simple qui simplifie le packaging
en mode non privilgi.

=head1 Options gnrales

 -h, --help				: Affichage de l'aide en ligne.
 -v, --verbose				: Mode verbeux, affichage d'information de deboggage.
 -b, --build				: Compilation automatique du package.
 -a, --archive=filename			: Cration d'un RPM  partir d'une archive
 -u, --uid=user id or name		: Identifiant utilisateur pour l'archive
 -g, --gid=user id or name		: Identifiant de groupe pour l'archive
 -n, --nodoc				: Annulation de la detection des fichiers de documentation 
 -i, --nostip				: Annulation de du retrait des informations des binaires 
 -c, --noconfig				: Annulation de la detection des fichiers de configuration
 -s, --noreserved			: Annulation de la detection des repertoires rservs
 -m, --multiple 			: Sparation en 3 packets : principal, doc et config
 -t, --template=filename		: Spcification d'un fichier template aternatif.
 -x, --exclude="pattern1,pattern2"	: Exclusion de certaines formes de fichier.
 -r, --root-directory=<directory>	: Rpertoire racine  ( / par dfaut ).
 -d, --directory=<directory>		: Rpertoire  packager.
 Par dfaut, la liste de fichiers est construite depuis le flux d'entre standard.
 -o, --optimize				: Tente d'optimiser la taille de la liste de fichier

=head1 Options du package RPM 

 -N, --name=<name>			: Nom du package - Option obligatoire.
 -V, --version=<version>		: Version du package - Option obligatoire.
 -R, --release=<release>		: Release du package - Option obligatoire.
 -C, --changelog=<changelog>		: ChangeLog du package
 -D, --description=<description>	: Description du package.
 -S, --summary=<summary>		: Rsum du package.
 -P, --packager=<packager>		: Identit du packageur.
 -U, --vendor-url=<vendor url>		: URL du fournisseur.
 -O, --vendor=<vendor>			: Nom du fournisseur.
 -A, --architecture=<archi>		: Architecture cible.
 -T, --distribution=<distro>		: Distribution cible.
 --requires=<dependency>,...		: Liste des dpendances.
 --build-script=<filename>		: Nom du script  inclure dans la session %build.
 --pre-script=<filename>		: Nom du script  inclure dans la session %pre.
 --post-script=<filename>		: Nom du script  inclure dans la session %post.
 --preun-script=<filename>		: Nom du script  inclure dans la session %preun.
 --postun-script=<filename>		: Nom du script  inclure dans la session %postun.

=head1 Exemples 

=head2 Ralisation rapide d'une image du rpertoire /home/jmrenouard/myrpmBuildDir

MyRPM -v -d /home/jmrenouard/myrpmBuildDir -r /home/jmrenouard/myrpmBuildDir -N toto -V 1.0 -R 1 -b

=head2 Une autre version

cd /home/jmrenouard/myrpmBuildDir && MyRPM -v -d . -r . -N toto -V 1.0 -R 1 -b

=head2 La mme avec des interactions avec les outils UNIX

cd /home/jmrenouard/myrpmBuildDir && find `pwd` -iname '*' -print | MyRPM -v -r /home/jmrenouard/myrpmBuildDir -N toto -V 1.0 -R 1 -b

find /home/jmrenouard/myrpmBuildDir | MyRPM -r /home/jmrenouard/myrpmBuildDir -N toto -V 1.0 -R 1

=head2 Explications

Le script ralise les oprations suivantes :

Find construit la liste de tous les fichiers contenus dans le rpertoie /home/jmrenouard/myrpmBuildDir.

MyRPM packages  tous les fichiers du rpertoie /home/jmrenouard/myrpmBuildDir dans le package ayant toto comme nom, 1.0 comme version et 1 comme release.

MyRPM considre /home/jmrenouard/myrpmBuildDir comme rpertoire root ( / ) si bien que tous les fichiers seront install  la racine par le programme rpm.


=head2 Repackager une configuration existante

rpm -ql yum |  MyRPM -v -N yum -V 2.7 -R 1_jmr -b

=head2 Explications

Rpm donne la liste des fichiers du package Yum install sur le systme.

MyRPM packages tous les fichiers de ce package dans un nouveau package avec yum comme nom.

Il s'agit d'un nouveau moyen de packager des modifications depuis un systme install.

=head1 Autres fonctionnalits

MyRPM support la cration de compte utilisateur et des   groupes. A la cration du RPM, MyRPM embarque les informations sur les groupes et utilisateurs. 
MyRPM construit des packages intelligents capable de vrifier la prsence de groupes et utilisateurs avant l'installation des fichiers .

MyRPM supporte aussi les liens symboliquesce qui facilite la substitution des liens "courant" aprs installation.

MyRPM est prouv en environnementde production et peut construire des RPMs volumineux facilement.
MyRPM supporte galement les noms de fichiers tordus tel que les fichiers compilsjava pour les classes internes.

MyRPM supporte l'ensemble des scripts  de pre et post install uninstall.


=head1 Exemple de fichier de configuration

Myrpm utilise le fichier utilisateur pour configurer les valeurs par dfaut.

=head2 Exemples de $HOME/.rpmmacros standard

%_topdir	/home/jmrenouard/redhat
%packager	Jean-Marie Renouard<jmrenouard@gmail.com>
%vendor	LightPath
%vendor_url	http://www.jmrenouard.fr
%distribution  Red Hat Enterprise 4/5/6
%dist_tag      .1
%_tmppath   	/var/tmp

=head1 Aide  l'amlioration du produit

=head2 Merci de soumettre les erreurs et les remarques sur http://code.google.com/p/myrpm/issues/list 

=head2 Vous pouvez contactez Jean-Marie Renouard <jmrenouard at gmail.com> pour plus de dtails.
